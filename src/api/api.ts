/* tslint:disable */
/* eslint-disable */
/**
 * Swap Coffee API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAmmType = {
    Volatile: 'volatile',
    Stable: 'stable'
} as const;

export type ApiAmmType = typeof ApiAmmType[keyof typeof ApiAmmType];


/**
 * 
 * @export
 * @interface ApiAuthToken
 */
export interface ApiAuthToken {
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiAuthToken
     */
    'administrative': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthToken
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiAuthToken
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAuthTokenOption = {
    AllowCycles: 'allow_cycles'
} as const;

export type ApiAuthTokenOption = typeof ApiAuthTokenOption[keyof typeof ApiAuthTokenOption];


/**
 * 
 * @export
 * @interface ApiBlockchain
 */
export interface ApiBlockchain {
    /**
     * 
     * @type {string}
     * @memberof ApiBlockchain
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiCreateAuthTokenRequest
 */
export interface ApiCreateAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCreateAuthTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiCreateAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiCreateAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiDex
 */
export interface ApiDex {
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiEditAuthTokenRequest
 */
export interface ApiEditAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiEditAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiEditAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface ApiPool
 */
export interface ApiPool {
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'address': string;
    /**
     * 
     * @type {ApiAmmType}
     * @memberof ApiPool
     */
    'amm_type': ApiAmmType;
    /**
     * 
     * @type {Array<ApiToken>}
     * @memberof ApiPool
     */
    'tokens': Array<ApiToken>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'extra_decimals'?: Array<number>;
    /**
     * 
     * @type {Array<ApiTokenRestrictions>}
     * @memberof ApiPool
     */
    'restrictions'?: Array<ApiTokenRestrictions>;
    /**
     * 
     * @type {ApiPoolFees}
     * @memberof ApiPool
     */
    'fees': ApiPoolFees;
}


/**
 * 
 * @export
 * @interface ApiPoolFees
 */
export interface ApiPoolFees {
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'average_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'divider'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'input'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'output'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'first_token'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'second_token'?: number;
}
/**
 * Configures the DEX pools that can appear in the generated route. By setting blockchains = [\"ton\"] inside it, you can remove the dexes field; max_volatility allows you to exclude pools whose volatility has been above a certain percentage in the last 15 minutes. This makes sense when you allow 2-3 intermediate tokens or a large number of splits to smooth out potential issues.
 * @export
 * @interface ApiPoolSelector
 */
export interface ApiPoolSelector {
    /**
     * If specified, only pools from given blockchains will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'blockchains'?: Array<string>;
    /**
     * If specified, only pools from given dexes will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'dexes'?: Array<string>;
    /**
     * If specified, only pools with volatility lower than given value will be used for routing
     * @type {number}
     * @memberof ApiPoolSelector
     */
    'max_volatility'?: number;
}
/**
 * 
 * @export
 * @interface ApiRecommendedGas
 */
export interface ApiRecommendedGas {
    /**
     * 
     * @type {string}
     * @memberof ApiRecommendedGas
     */
    'blockchain': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRecommendedGas
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiRoute
 */
export interface ApiRoute {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'savings'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'left_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'recommended_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'price_impact': number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoute
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiRouteRequest
 */
export interface ApiRouteRequest {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'input_token': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'output_token': ApiTokenAddress;
    /**
     * Input amount in tokens (not nano!) to be swapped
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'input_amount'?: number;
    /**
     * If specified, the route will be built to get the specified output amount. If not specified, the route will be built to get the maximum output amount for the given input amount.
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'output_amount'?: number;
    /**
     * Defines the maximum number of independent paths (i.e., transactions) the route can split into. For v4 wallets, you can omit this or set it to 4; for v5 wallets, you can set it to 20 (this is our internal upper limit, and we may reduce it to 10).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_splits'?: number;
    /**
     * Defines the maximum length of each path in tokens. It accepts values from [2; 5]. If it\'s 2, only direct swaps A -> B without multihops are possible. If it\'s 3, there can be a maximum of 1 intermediate token, i.e., A -> X -> B. If it\'s 4/5, there can be 2/3 intermediate tokens. A value of 2 deprives you of more profitable exchanges by finding market inefficiencies and does not allow you to exchange tokens without a direct pair (since there can be no intermediate tokens). The higher the value, the more profitable routes can be built, but the higher the likelihood that the user ends up with an intermediate token (since our blockchain is asynchronous, and some swap in the middle of the route may fail due to slippage).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_length'?: number;
    /**
     * 
     * @type {ApiPoolSelector}
     * @memberof ApiRouteRequest
     */
    'pool_selector'?: ApiPoolSelector;
}
/**
 * 
 * @export
 * @interface ApiRoutingStep
 */
export interface ApiRoutingStep {
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'pool_address': string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {ApiSwap}
     * @memberof ApiRoutingStep
     */
    'swap': ApiSwap;
    /**
     * 
     * @type {number}
     * @memberof ApiRoutingStep
     */
    'recommended_gas': number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoutingStep
     */
    'next'?: Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiSwap
 */
export interface ApiSwap {
    /**
     * 
     * @type {ApiSwapResult}
     * @memberof ApiSwap
     */
    'result': ApiSwapResult;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'output_amount': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'before_reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'after_reserves': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ApiSwap
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'left_amount'?: number;
}


/**
 * Result of the swap
 * @export
 * @enum {string}
 */

export const ApiSwapResult = {
    FullyFulfilled: 'fully_fulfilled',
    PartiallyFulfilled: 'partially_fulfilled',
    Unavailable: 'unavailable'
} as const;

export type ApiSwapResult = typeof ApiSwapResult[keyof typeof ApiSwapResult];


/**
 * 
 * @export
 * @interface ApiSwapTransaction
 */
export interface ApiSwapTransaction {
    /**
     * 
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'address': string;
    /**
     * Amount of nanotons to be sent. Can be passed to TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'value': string;
    /**
     * Base64-encoded cell. Treated as a payload field in TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'cell': string;
    /**
     * Internal message send mode. More here https://docs.ton.org/develop/smart-contracts/messages#message-modes
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'send_mode': number;
    /**
     * Unique identifier of the query used for tracking swap.coffee transactions among others
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'query_id': number;
}
/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiToken
     */
    'address': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenMetadata}
     * @memberof ApiToken
     */
    'metadata': ApiTokenMetadata;
}
/**
 * 
 * @export
 * @interface ApiTokenAddress
 */
export interface ApiTokenAddress {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface ApiTokenMetadata
 */
export interface ApiTokenMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenMetadata
     */
    'decimals': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiTokenMetadata
     */
    'listed': boolean;
}
/**
 * 
 * @export
 * @interface ApiTokenRestrictions
 */
export interface ApiTokenRestrictions {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'min_swap_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'max_swap_amount'?: number;
}
/**
 * 
 * @export
 * @interface ApiTransactionResult
 */
export interface ApiTransactionResult {
    /**
     * 
     * @type {ApiTransactionStatus}
     * @memberof ApiTransactionResult
     */
    'status': ApiTransactionStatus;
    /**
     * 
     * @type {Array<ApiTransactionStepResult>}
     * @memberof ApiTransactionResult
     */
    'steps': Array<ApiTransactionStepResult>;
    /**
     * 
     * @type {ApiTransactionResultItem}
     * @memberof ApiTransactionResult
     */
    'input'?: ApiTransactionResultItem;
    /**
     * 
     * @type {ApiTransactionResultItem}
     * @memberof ApiTransactionResult
     */
    'output'?: ApiTransactionResultItem;
}


/**
 * 
 * @export
 * @interface ApiTransactionResultItem
 */
export interface ApiTransactionResultItem {
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionResultItem
     */
    'token_blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionResultItem
     */
    'token_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTransactionResultItem
     */
    'amount': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStatus = {
    Pending: 'pending',
    PartiallyComplete: 'partially_complete',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStatus = typeof ApiTransactionStatus[keyof typeof ApiTransactionStatus];


/**
 * 
 * @export
 * @interface ApiTransactionStepResult
 */
export interface ApiTransactionStepResult {
    /**
     * 
     * @type {ApiTransactionStepStatus}
     * @memberof ApiTransactionStepResult
     */
    'status': ApiTransactionStepStatus;
    /**
     * 
     * @type {ApiTransactionResultItem}
     * @memberof ApiTransactionStepResult
     */
    'input'?: ApiTransactionResultItem;
    /**
     * 
     * @type {ApiTransactionResultItem}
     * @memberof ApiTransactionStepResult
     */
    'output'?: ApiTransactionResultItem;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStepStatus = {
    Pending: 'pending',
    Cancelled: 'cancelled',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStepStatus = typeof ApiTransactionStepStatus[keyof typeof ApiTransactionStepStatus];


/**
 * 
 * @export
 * @interface ApiTransactionsRequest
 */
export interface ApiTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'sender_address': string;
    /**
     * Slippage in fractions (1 = 100%, 0 = 0%). If the slippage is exceeded, the transaction will not be executed and intermediate tokens will be returned to the sender.
     * @type {number}
     * @memberof ApiTransactionsRequest
     */
    'slippage': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'referral_name'?: string;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiTransactionsRequest
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiTransactionsResponse
 */
export interface ApiTransactionsResponse {
    /**
     * Unique identifier of the route used for tracking.
     * @type {number}
     * @memberof ApiTransactionsResponse
     */
    'route_id': number;
    /**
     * 
     * @type {Array<ApiSwapTransaction>}
     * @memberof ApiTransactionsResponse
     */
    'transactions': Array<ApiSwapTransaction>;
}
/**
 * 
 * @export
 * @interface GetBlockchainsDefaultResponse
 */
export interface GetBlockchainsDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof GetBlockchainsDefaultResponse
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface GetWalletVersion200Response
 */
export interface GetWalletVersion200Response {
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'revision': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCreateAuthTokenRequest' is not null or undefined
            assertParamExists('createAuthToken', 'apiCreateAuthTokenRequest', apiCreateAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCreateAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteAuthToken', 'key', key)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken: async (apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiEditAuthTokenRequest' is not null or undefined
            assertParamExists('editAuthToken', 'apiEditAuthTokenRequest', apiEditAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiEditAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(apiCreateAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.createAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthToken(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthToken(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAuthToken(apiEditAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.editAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiAuthToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getAuthTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: any): AxiosPromise<ApiAuthToken> {
            return localVarFp.createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken(key: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAuthToken(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: any): AxiosPromise<ApiAuthToken> {
            return localVarFp.editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens(options?: any): AxiosPromise<Array<ApiAuthToken>> {
            return localVarFp.getAuthTokens(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Create new auth token
     * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing auth token
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteAuthToken(key: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteAuthToken(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit existing auth token
     * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing auth tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthTokens(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/blockchains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex: async (blockchain: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getDex', 'blockchain', blockchain)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDex', 'name', name)
            const localVarPath = `/v1/dex/{blockchain}/{name}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes: async (blockchain?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getPool', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPool', 'address', address)
            const localVarPath = `/v1/pool/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getToken', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getToken', 'address', address)
            const localVarPath = `/v1/token/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (listed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (listed !== undefined) {
                localVarQueryParameter['listed'] = listed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol: async (blockchain: string, symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getTokensBySymbol', 'blockchain', blockchain)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTokensBySymbol', 'symbol', symbol)
            const localVarPath = `/v1/token/{blockchain}/by-symbol/{symbol}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration)
    return {
        /**
         * Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockchains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiBlockchain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockchains(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getBlockchains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDex>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDex(blockchain, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDexes(blockchain?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiDex>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDexes(blockchain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDexes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(listed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(listed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokensBySymbol(blockchain, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokensBySymbol']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityApiFp(configuration)
    return {
        /**
         * Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains(options?: any): AxiosPromise<Array<ApiBlockchain>> {
            return localVarFp.getBlockchains(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex(blockchain: string, name: string, options?: any): AxiosPromise<ApiDex> {
            return localVarFp.getDex(blockchain, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes(blockchain?: string, options?: any): AxiosPromise<Array<ApiDex>> {
            return localVarFp.getDexes(blockchain, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(blockchain: string, address: string, options?: any): AxiosPromise<ApiPool> {
            return localVarFp.getPool(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(blockchain: string, address: string, options?: any): AxiosPromise<ApiToken> {
            return localVarFp.getToken(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(listed?: boolean, options?: any): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokens(listed, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol(blockchain: string, symbol: string, options?: any): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokensBySymbol(blockchain, symbol, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI {
    /**
     * Get supported blockchains. Currently only TON is supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getBlockchains(options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getBlockchains(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given decentralized exchange for the given blockchain
     * @param {string} blockchain 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDex(blockchain, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of supported decentralized exchanges supported by the service in the given blockchain
     * @param {string} [blockchain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDexes(blockchain?: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDexes(blockchain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given liquidity pool for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getPool(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given token for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getToken(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of tokens supported by the service
     * @param {boolean} [listed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokens(listed?: boolean, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokens(listed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given token by its symbol for the given blockchain
     * @param {string} blockchain 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokensBySymbol(blockchain, symbol, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoutingApi - axios parameter creator
 * @export
 */
export const RoutingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute: async (apiRouteRequest: ApiRouteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiRouteRequest' is not null or undefined
            assertParamExists('buildRoute', 'apiRouteRequest', apiRouteRequest)
            const localVarPath = `/v1/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRouteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        buildTransactions: async (apiTransactionsRequest: ApiTransactionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTransactionsRequest' is not null or undefined
            assertParamExists('buildTransactions', 'apiTransactionsRequest', apiTransactionsRequest)
            const localVarPath = `/v1/route/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2: async (apiTransactionsRequest: ApiTransactionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTransactionsRequest' is not null or undefined
            assertParamExists('buildTransactionsV2', 'apiTransactionsRequest', apiTransactionsRequest)
            const localVarPath = `/v2/route/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsResult: async (queryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('getTransactionsResult', 'queryId', queryId)
            const localVarPath = `/v1/route/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (queryId !== undefined) {
                localVarQueryParameter['query_id'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutingApi - functional programming interface
 * @export
 */
export const RoutingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoutingApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildRoute(apiRouteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async buildTransactions(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiSwapTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTransactions(apiTransactionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTransactionsV2(apiTransactionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTransactionsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTransactionResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsResult(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.getTransactionsResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoutingApi - factory interface
 * @export
 */
export const RoutingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutingApiFp(configuration)
    return {
        /**
         * Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute(apiRouteRequest: ApiRouteRequest, options?: any): AxiosPromise<ApiRoute> {
            return localVarFp.buildRoute(apiRouteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        buildTransactions(apiTransactionsRequest: ApiTransactionsRequest, options?: any): AxiosPromise<Array<ApiSwapTransaction>> {
            return localVarFp.buildTransactions(apiTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: any): AxiosPromise<ApiTransactionsResponse> {
            return localVarFp.buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsResult(queryId: number, options?: any): AxiosPromise<Array<ApiTransactionResult>> {
            return localVarFp.getTransactionsResult(queryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutingApi - object-oriented interface
 * @export
 * @class RoutingApi
 * @extends {BaseAPI}
 */
export class RoutingApi extends BaseAPI {
    /**
     * Returns the best route for the given trade pair
     * @param {ApiRouteRequest} apiRouteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildRoute(apiRouteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
     * @param {ApiTransactionsRequest} apiTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTransactions(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTransactions(apiTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
     * @param {ApiTransactionsRequest} apiTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get route transactions execution result
     * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).getTransactionsResult(queryId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TonApi - axios parameter creator
 * @export
 */
export const TonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletBalance', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/balance`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletVersion', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/version`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TonApi - functional programming interface
 * @export
 */
export const TonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TonApiAxiosParamCreator(configuration)
    return {
        /**
         * Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletBalance(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletVersion(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWalletVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletVersion(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TonApi - factory interface
 * @export
 */
export const TonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TonApiFp(configuration)
    return {
        /**
         * Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance(address: string, options?: any): AxiosPromise<string> {
            return localVarFp.getWalletBalance(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion(address: string, options?: any): AxiosPromise<GetWalletVersion200Response> {
            return localVarFp.getWalletVersion(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TonApi - object-oriented interface
 * @export
 * @class TonApi
 * @extends {BaseAPI}
 */
export class TonApi extends BaseAPI {
    /**
     * Get wallet balance in nanotons (1e-9 TON)
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletBalance(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletBalance(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns wallet version and revision
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletVersion(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletVersion(address, options).then((request) => request(this.axios, this.basePath));
    }
}



