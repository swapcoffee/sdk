/* tslint:disable */
/* eslint-disable */
/**
 * Swap Coffee API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAmmType = {
    Volatile: 'volatile',
    Stable: 'stable'
} as const;

export type ApiAmmType = typeof ApiAmmType[keyof typeof ApiAmmType];


/**
 * 
 * @export
 * @interface ApiAuthToken
 */
export interface ApiAuthToken {
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthToken
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiAuthToken
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAuthTokenOption = {
    Administrator: 'administrator',
    Moderator: 'moderator',
    AllowCycles: 'allow_cycles',
    ExtendedTxStatus: 'extended_tx_status'
} as const;

export type ApiAuthTokenOption = typeof ApiAuthTokenOption[keyof typeof ApiAuthTokenOption];


/**
 * 
 * @export
 * @interface ApiBlockchain
 */
export interface ApiBlockchain {
    /**
     * 
     * @type {string}
     * @memberof ApiBlockchain
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiCashbackCreateRequest
 */
export interface ApiCashbackCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'description': string;
    /**
     * Where rewards stored
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'distributor': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'reward_token': string;
    /**
     * 
     * @type {Array<ApiDexSwapCondition>}
     * @memberof ApiCashbackCreateRequest
     */
    'conditions': Array<ApiDexSwapCondition>;
    /**
     * How many tokens will be distributed to users
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'distribute': number;
    /**
     * How many tokens already distributed to users
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'distributed': number;
    /**
     * Begin cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'start_time_seconds': number;
    /**
     * End cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'end_time_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'reward_denominator': number;
    /**
     * 
     * @type {Array<ApiCashbackLimitCreateRequest>}
     * @memberof ApiCashbackCreateRequest
     */
    'limits': Array<ApiCashbackLimitCreateRequest>;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'image_url': string;
    /**
     * 
     * @type {Array<ApiContentReference>}
     * @memberof ApiCashbackCreateRequest
     */
    'references': Array<ApiContentReference>;
}
/**
 * 
 * @export
 * @interface ApiCashbackInfo
 */
export interface ApiCashbackInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'description': string;
    /**
     * Where rewards stored
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'distributor': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'reward_token': string;
    /**
     * 
     * @type {Array<ApiDexSwapCondition>}
     * @memberof ApiCashbackInfo
     */
    'conditions': Array<ApiDexSwapCondition>;
    /**
     * How many tokens will be distributed to users
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'distribute': number;
    /**
     * How many tokens already distributed to users
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'distributed': number;
    /**
     * Begin cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'start_time_seconds': number;
    /**
     * End cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'end_time_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'reward_denominator': number;
    /**
     * Can this cashback program accrue tokens to participants
     * @type {boolean}
     * @memberof ApiCashbackInfo
     */
    'is_active': boolean;
    /**
     * 
     * @type {Array<ApiCashbackLimit>}
     * @memberof ApiCashbackInfo
     */
    'limits': Array<ApiCashbackLimit>;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'image_url': string;
    /**
     * 
     * @type {Array<ApiContentReference>}
     * @memberof ApiCashbackInfo
     */
    'references': Array<ApiContentReference>;
}
/**
 * 
 * @export
 * @interface ApiCashbackInfoResponse
 */
export interface ApiCashbackInfoResponse {
    /**
     * Total amount of similar cashback promos
     * @type {number}
     * @memberof ApiCashbackInfoResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<ApiCashbackInfo>}
     * @memberof ApiCashbackInfoResponse
     */
    'infos': Array<ApiCashbackInfo>;
}
/**
 * 
 * @export
 * @interface ApiCashbackLimit
 */
export interface ApiCashbackLimit {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimit
     */
    'limit_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimit
     */
    'interval_duration_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimit
     */
    'max_distribute_at_interval': number;
}
/**
 * 
 * @export
 * @interface ApiCashbackLimitCreateRequest
 */
export interface ApiCashbackLimitCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitCreateRequest
     */
    'interval_duration_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitCreateRequest
     */
    'max_distribute_at_interval': number;
}
/**
 * 
 * @export
 * @interface ApiCashbackLimitUpdateRequest
 */
export interface ApiCashbackLimitUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitUpdateRequest
     */
    'limit_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitUpdateRequest
     */
    'interval_duration_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitUpdateRequest
     */
    'max_distribute_at_interval'?: number;
}
/**
 * 
 * @export
 * @interface ApiCashbackUpdateRequest
 */
export interface ApiCashbackUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'description'?: string;
    /**
     * Where rewards stored
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'distributor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'reward_token'?: string;
    /**
     * 
     * @type {Array<ApiDexSwapCondition>}
     * @memberof ApiCashbackUpdateRequest
     */
    'conditions'?: Array<ApiDexSwapCondition>;
    /**
     * How many tokens will be distributed to users
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'distribute'?: number;
    /**
     * How many tokens already distributed to users
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'distributed'?: number;
    /**
     * Begin cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'start_time_seconds'?: number;
    /**
     * End cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'end_time_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'reward_denominator'?: number;
    /**
     * 
     * @type {Array<ApiCashbackLimitUpdateRequest>}
     * @memberof ApiCashbackUpdateRequest
     */
    'limits'?: Array<ApiCashbackLimitUpdateRequest>;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {Array<ApiContentReference>}
     * @memberof ApiCashbackUpdateRequest
     */
    'references'?: Array<ApiContentReference>;
}
/**
 * 
 * @export
 * @interface ApiClaimState
 */
export interface ApiClaimState {
    /**
     * 
     * @type {ApiClaimingType}
     * @memberof ApiClaimState
     */
    'type': ApiClaimingType;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimState
     */
    'query_id': number;
    /**
     * When transaction happened in blockchain - unix seconds
     * @type {number}
     * @memberof ApiClaimState
     */
    'unix_time': number;
    /**
     * When transaction happened in blockchain - on-chain logical time
     * @type {number}
     * @memberof ApiClaimState
     */
    'logical_time': number;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimState
     */
    'transaction_hash': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimState
     */
    'token_address': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimState
     */
    'wallet_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimState
     */
    'amount': number;
    /**
     * 
     * @type {ApiWithdrawal}
     * @memberof ApiClaimState
     */
    'withdrawal': ApiWithdrawal;
}


/**
 * 
 * @export
 * @interface ApiClaimStateResponse
 */
export interface ApiClaimStateResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStateResponse
     */
    'total_count': number;
    /**
     * 
     * @type {Array<ApiClaimState>}
     * @memberof ApiClaimStateResponse
     */
    'items': Array<ApiClaimState>;
}
/**
 * 
 * @export
 * @interface ApiClaimingStats
 */
export interface ApiClaimingStats {
    /**
     * 
     * @type {Array<ApiClaimingTypeStats>}
     * @memberof ApiClaimingStats
     */
    'aggregated': Array<ApiClaimingTypeStats>;
    /**
     * 
     * @type {Array<ApiClaimingTokenStats>}
     * @memberof ApiClaimingStats
     */
    'detailed': Array<ApiClaimingTokenStats>;
}
/**
 * 
 * @export
 * @interface ApiClaimingTokenStats
 */
export interface ApiClaimingTokenStats {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiClaimingTokenStats
     */
    'token': ApiToken;
    /**
     * Wallet\'s address where token resides
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'wallet': string;
    /**
     * 
     * @type {ApiClaimingType}
     * @memberof ApiClaimingTokenStats
     */
    'type': ApiClaimingType;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'claimed': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'locked': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'available': string;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimingTokenStats
     */
    'available_usd': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiClaimingType = {
    All: 'all',
    Referral: 'referral',
    Cashback: 'cashback',
    Staking: 'staking',
    RewardsStonfi: 'rewards_stonfi',
    RewardsDedust: 'rewards_dedust'
} as const;

export type ApiClaimingType = typeof ApiClaimingType[keyof typeof ApiClaimingType];


/**
 * 
 * @export
 * @interface ApiClaimingTypeStats
 */
export interface ApiClaimingTypeStats {
    /**
     * 
     * @type {ApiClaimingType}
     * @memberof ApiClaimingTypeStats
     */
    'type': ApiClaimingType;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimingTypeStats
     */
    'available_usd': number;
}


/**
 * 
 * @export
 * @interface ApiContentReference
 */
export interface ApiContentReference {
    /**
     * 
     * @type {string}
     * @memberof ApiContentReference
     */
    'ref_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiContentReference
     */
    'ref_url': string;
}
/**
 * 
 * @export
 * @interface ApiContestInfo
 */
export interface ApiContestInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiContestInfo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiContestInfo
     */
    'description': string;
    /**
     * 
     * @type {Array<ApiContentReference>}
     * @memberof ApiContestInfo
     */
    'references': Array<ApiContentReference>;
    /**
     * 
     * @type {Array<ApiDexSwapCondition>}
     * @memberof ApiContestInfo
     */
    'conditions': Array<ApiDexSwapCondition>;
    /**
     * 
     * @type {Array<ApiContestReward>}
     * @memberof ApiContestInfo
     */
    'rewards': Array<ApiContestReward>;
    /**
     * in seconds
     * @type {number}
     * @memberof ApiContestInfo
     */
    'start_time_unix': number;
    /**
     * in seconds
     * @type {number}
     * @memberof ApiContestInfo
     */
    'end_time_unix': number;
    /**
     * 
     * @type {string}
     * @memberof ApiContestInfo
     */
    'image_url': string;
    /**
     * 
     * @type {string}
     * @memberof ApiContestInfo
     */
    'total_reward': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiContestInfo
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface ApiContestInfoWithID
 */
export interface ApiContestInfoWithID {
    /**
     * 
     * @type {number}
     * @memberof ApiContestInfoWithID
     */
    'id': number;
    /**
     * 
     * @type {ApiContestInfo}
     * @memberof ApiContestInfoWithID
     */
    'info': ApiContestInfo;
}
/**
 * 
 * @export
 * @interface ApiContestReward
 */
export interface ApiContestReward {
    /**
     * 
     * @type {string}
     * @memberof ApiContestReward
     */
    'reward': string;
    /**
     * 
     * @type {number}
     * @memberof ApiContestReward
     */
    'place'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiContestReward
     */
    'place_from'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiContestReward
     */
    'place_to'?: number;
}
/**
 * 
 * @export
 * @interface ApiContestUserStats
 */
export interface ApiContestUserStats {
    /**
     * 
     * @type {string}
     * @memberof ApiContestUserStats
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiContestUserStats
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof ApiContestUserStats
     */
    'volume_usd': number;
}
/**
 * 
 * @export
 * @interface ApiCreateAuthTokenRequest
 */
export interface ApiCreateAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCreateAuthTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiCreateAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiCreateAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiCreateStakeRequest
 */
export interface ApiCreateStakeRequest {
    /**
     * Token to be staked.
     * @type {string}
     * @memberof ApiCreateStakeRequest
     */
    'asset_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiCreateStakeRequest
     */
    'amount_to_stake_raw': number;
    /**
     * Lock identifier.
     * @type {number}
     * @memberof ApiCreateStakeRequest
     */
    'period_id': number;
}
/**
 * 
 * @export
 * @interface ApiDex
 */
export interface ApiDex {
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiDexSwapCondition
 */
export interface ApiDexSwapCondition {
    /**
     * 
     * @type {ApiDexSwapConditionType}
     * @memberof ApiDexSwapCondition
     */
    'type': ApiDexSwapConditionType;
    /**
     * Arguments required to construct condition type
     * @type {Array<string>}
     * @memberof ApiDexSwapCondition
     */
    'args'?: Array<string>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiDexSwapConditionType = {
    Unique: 'unique',
    Listed: 'listed',
    PartnerAddress: 'partner_address',
    Tokens: 'tokens',
    TokensPair: 'tokens-pair',
    TokensExact: 'tokens-exact',
    UsersWhitelist: 'users-whitelist',
    SwapTxMinAmount: 'swap-tx-min-amount',
    BlacklistPair: 'blacklist-pair',
    BlacklistTokens: 'blacklist-tokens'
} as const;

export type ApiDexSwapConditionType = typeof ApiDexSwapConditionType[keyof typeof ApiDexSwapConditionType];


/**
 * 
 * @export
 * @interface ApiEditAuthTokenRequest
 */
export interface ApiEditAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiEditAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiEditAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface ApiExtendStakeRequest
 */
export interface ApiExtendStakeRequest {
    /**
     * Lock identifier.
     * @type {number}
     * @memberof ApiExtendStakeRequest
     */
    'period_id': number;
}
/**
 * 
 * @export
 * @interface ApiHistoricalTransaction
 */
export interface ApiHistoricalTransaction {
    /**
     * 
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'route_id': number;
    /**
     * When transaction happened in blockchain - unix seconds
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'unix_time': number;
    /**
     * When transaction happened in blockchain - on-chain logical time
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'logical_time': number;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiHistoricalTransaction
     */
    'from': ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiHistoricalTransaction
     */
    'to': ApiQuantifiedToken;
    /**
     * 
     * @type {string}
     * @memberof ApiHistoricalTransaction
     */
    'dex': string;
}
/**
 * 
 * @export
 * @interface ApiPool
 */
export interface ApiPool {
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'address': string;
    /**
     * 
     * @type {ApiPoolType}
     * @memberof ApiPool
     */
    'type': ApiPoolType;
    /**
     * 
     * @type {ApiAmmType}
     * @memberof ApiPool
     */
    'amm_type': ApiAmmType;
    /**
     * 
     * @type {Array<ApiToken>}
     * @memberof ApiPool
     */
    'tokens': Array<ApiToken>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'extra_decimals'?: Array<number>;
    /**
     * 
     * @type {Array<ApiTokenRestrictions>}
     * @memberof ApiPool
     */
    'restrictions'?: Array<ApiTokenRestrictions>;
    /**
     * 
     * @type {ApiPoolFees}
     * @memberof ApiPool
     */
    'fees': ApiPoolFees;
}


/**
 * 
 * @export
 * @interface ApiPoolFees
 */
export interface ApiPoolFees {
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'average_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'divider'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'input'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'output'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'first_token'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'second_token'?: number;
}
/**
 * Configures the DEX pools that can appear in the generated route. By setting blockchains = [\"ton\"] inside it, you can remove the dexes field; max_volatility allows you to exclude pools whose volatility has been above a certain percentage in the last 15 minutes. This makes sense when you allow 2-3 intermediate tokens or a large number of splits to smooth out potential issues.
 * @export
 * @interface ApiPoolSelector
 */
export interface ApiPoolSelector {
    /**
     * If specified, only pools from given blockchains will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'blockchains'?: Array<string>;
    /**
     * If specified, only pools from given dexes will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'dexes'?: Array<string>;
    /**
     * If specified, only pools with volatility lower than given value will be used for routing
     * @type {number}
     * @memberof ApiPoolSelector
     */
    'max_volatility'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiPoolType = {
    Public: 'public',
    Private: 'private',
    Slumbering: 'slumbering',
    Invalid: 'invalid'
} as const;

export type ApiPoolType = typeof ApiPoolType[keyof typeof ApiPoolType];


/**
 * 
 * @export
 * @interface ApiProofValidationRequest
 */
export interface ApiProofValidationRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiProofValidationRequest
     */
    'public_key': string;
    /**
     * Base64-encoded initial state. Must be retrieved from ton-connect.
     * @type {string}
     * @memberof ApiProofValidationRequest
     */
    'wallet_state_init': string;
    /**
     * 
     * @type {ApiTonProof}
     * @memberof ApiProofValidationRequest
     */
    'proof': ApiTonProof;
}
/**
 * 
 * @export
 * @interface ApiQuantifiedToken
 */
export interface ApiQuantifiedToken {
    /**
     * 
     * @type {string}
     * @memberof ApiQuantifiedToken
     */
    'token_blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiQuantifiedToken
     */
    'token_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiQuantifiedToken
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiRawTransactionRecord
 */
export interface ApiRawTransactionRecord {
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'query_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'route_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'hash': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'lt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'user_wallet': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'token_from': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'token_to': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_from': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_from_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_to': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_to_usd': number;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'dex': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'ref_fee_usd': number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRawTransactionRecord
     */
    'failed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRawTransactionRecord
     */
    'suspicious': boolean;
}
/**
 * 
 * @export
 * @interface ApiRecommendedGas
 */
export interface ApiRecommendedGas {
    /**
     * 
     * @type {string}
     * @memberof ApiRecommendedGas
     */
    'blockchain': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRecommendedGas
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountInfo
 */
export interface ApiReferralAccountInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiReferralAccountInfo
     */
    'link': string;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'fees_percentage': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'referrals_count': number;
    /**
     * Number of transactions sent by referral users
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'transactions_count': number;
    /**
     * 
     * @type {ApiReferralAccountRewards}
     * @memberof ApiReferralAccountInfo
     */
    'rewards': ApiReferralAccountRewards;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountInfoUpdate
 */
export interface ApiReferralAccountInfoUpdate {
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfoUpdate
     */
    'fees_percentage': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountReward
 */
export interface ApiReferralAccountReward {
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountReward
     */
    'volume': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountReward
     */
    'fees': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountRewards
 */
export interface ApiReferralAccountRewards {
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralAccountRewards
     */
    'monthly': ApiReferralAccountReward;
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralAccountRewards
     */
    'total': ApiReferralAccountReward;
}
/**
 * 
 * @export
 * @interface ApiReferralInfo
 */
export interface ApiReferralInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiReferralInfo
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralInfo
     */
    'transactions_count': number;
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralInfo
     */
    'rewards': ApiReferralAccountReward;
}
/**
 * 
 * @export
 * @interface ApiRoute
 */
export interface ApiRoute {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'savings'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'left_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'recommended_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'price_impact': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'estimated_cashback_usd'?: number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoute
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiRouteRequest
 */
export interface ApiRouteRequest {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'input_token': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'output_token': ApiTokenAddress;
    /**
     * Input amount in tokens (not nano!) to be swapped
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'input_amount'?: number;
    /**
     * If specified, the route will be built to get the specified output amount. If not specified, the route will be built to get the maximum output amount for the given input amount.
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'output_amount'?: number;
    /**
     * Defines the maximum number of independent paths (i.e., transactions) the route can split into. For v4 wallets, you can omit this or set it to 4; for v5 wallets, you can set it to 20 (this is our internal upper limit, and we may reduce it to 10).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_splits'?: number;
    /**
     * Defines the maximum length of each path in tokens. It accepts values from [2; 5]. If it\'s 2, only direct swaps A -> B without multihops are possible. If it\'s 3, there can be a maximum of 1 intermediate token, i.e., A -> X -> B. If it\'s 4/5, there can be 2/3 intermediate tokens. A value of 2 deprives you of more profitable exchanges by finding market inefficiencies and does not allow you to exchange tokens without a direct pair (since there can be no intermediate tokens). The higher the value, the more profitable routes can be built, but the higher the likelihood that the user ends up with an intermediate token (since our blockchain is asynchronous, and some swap in the middle of the route may fail due to slippage).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_length'?: number;
    /**
     * 
     * @type {ApiPoolSelector}
     * @memberof ApiRouteRequest
     */
    'pool_selector'?: ApiPoolSelector;
    /**
     * 
     * @type {ApiRouteRequestAdditionalData}
     * @memberof ApiRouteRequest
     */
    'additional_data'?: ApiRouteRequestAdditionalData;
}
/**
 * 
 * @export
 * @interface ApiRouteRequestAdditionalData
 */
export interface ApiRouteRequestAdditionalData {
    /**
     * 
     * @type {string}
     * @memberof ApiRouteRequestAdditionalData
     */
    'sender_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiRouteRequestAdditionalData
     */
    'referral_name'?: string;
}
/**
 * 
 * @export
 * @interface ApiRouteResult
 */
export interface ApiRouteResult {
    /**
     * 
     * @type {Array<ApiSplitResult>}
     * @memberof ApiRouteResult
     */
    'splits': Array<ApiSplitResult>;
    /**
     * Whether this is the final view of the route result (i.e. it won\'t change anymore) and therefore it will be invalidated from our cache soon
     * @type {boolean}
     * @memberof ApiRouteResult
     */
    'terminal': boolean;
}
/**
 * 
 * @export
 * @interface ApiRoutingStep
 */
export interface ApiRoutingStep {
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'pool_address': string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {ApiSwap}
     * @memberof ApiRoutingStep
     */
    'swap': ApiSwap;
    /**
     * 
     * @type {number}
     * @memberof ApiRoutingStep
     */
    'recommended_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoutingStep
     */
    'average_gas': number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoutingStep
     */
    'next'?: Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiSplitResult
 */
export interface ApiSplitResult {
    /**
     * 
     * @type {ApiTransactionStatus}
     * @memberof ApiSplitResult
     */
    'status': ApiTransactionStatus;
    /**
     * 
     * @type {Array<ApiSplitStepResult>}
     * @memberof ApiSplitResult
     */
    'steps': Array<ApiSplitStepResult>;
    /**
     * 
     * @type {ApiTokenWithAmount}
     * @memberof ApiSplitResult
     */
    'input'?: ApiTokenWithAmount;
    /**
     * 
     * @type {ApiTokenWithAmount}
     * @memberof ApiSplitResult
     */
    'output'?: ApiTokenWithAmount;
    /**
     * Whether funds were paid from the pools to their receiver
     * @type {boolean}
     * @memberof ApiSplitResult
     */
    'paid': boolean;
    /**
     * Amount of nanotons, dedicated to be spent on gas
     * @type {number}
     * @memberof ApiSplitResult
     */
    'gas_sent': number;
    /**
     * Amount of nanotons, dedicated to be spent on gas, that have been returned. Present only when paid is true
     * @type {number}
     * @memberof ApiSplitResult
     */
    'gas_received'?: number;
}


/**
 * 
 * @export
 * @interface ApiSplitStepResult
 */
export interface ApiSplitStepResult {
    /**
     * 
     * @type {ApiTransactionStepStatus}
     * @memberof ApiSplitStepResult
     */
    'status': ApiTransactionStepStatus;
    /**
     * 
     * @type {ApiTokenWithAmount}
     * @memberof ApiSplitStepResult
     */
    'input'?: ApiTokenWithAmount;
    /**
     * 
     * @type {ApiTokenWithAmount}
     * @memberof ApiSplitStepResult
     */
    'output'?: ApiTokenWithAmount;
}


/**
 * 
 * @export
 * @interface ApiStakingGlobalInfo
 */
export interface ApiStakingGlobalInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiStakingGlobalInfo
     */
    'total_points': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingGlobalInfo
     */
    'apr': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingGlobalInfo
     */
    'total_locked_native': number;
    /**
     * 
     * @type {Array<ApiStakingTokenInfoLock>}
     * @memberof ApiStakingGlobalInfo
     */
    'locked_tokens': Array<ApiStakingTokenInfoLock>;
    /**
     * 
     * @type {Array<ApiStakingTokenInfo>}
     * @memberof ApiStakingGlobalInfo
     */
    'distributed_rewards': Array<ApiStakingTokenInfo>;
    /**
     * 
     * @type {Array<ApiStakingRewardsTokenInfo>}
     * @memberof ApiStakingGlobalInfo
     */
    'actual_rewards': Array<ApiStakingRewardsTokenInfo>;
    /**
     * 
     * @type {Array<ApiStakingPositionPeriods>}
     * @memberof ApiStakingGlobalInfo
     */
    'periods': Array<ApiStakingPositionPeriods>;
}
/**
 * 
 * @export
 * @interface ApiStakingInfo
 */
export interface ApiStakingInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiStakingInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiStakingInfo
     */
    'master_address': string;
}
/**
 * 
 * @export
 * @interface ApiStakingPositionInfo
 */
export interface ApiStakingPositionInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'id': number;
    /**
     * Staked token
     * @type {string}
     * @memberof ApiStakingPositionInfo
     */
    'locked_asset_address': string;
    /**
     * Staked token amount in raw
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'locked_asset_amount_raw': number;
    /**
     * Staked token volume converted to main staking token
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'locked_native': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'locked_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'start_lock_seconds_utc': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'end_lock_seconds_utc': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'points_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingPositionInfo
     */
    'period_id': number;
    /**
     * 
     * @type {Array<ApiStakingPositionPeriods>}
     * @memberof ApiStakingPositionInfo
     */
    'available_periods': Array<ApiStakingPositionPeriods>;
    /**
     * 
     * @type {Array<ApiStakingTokenInfo>}
     * @memberof ApiStakingPositionInfo
     */
    'earned_rewards': Array<ApiStakingTokenInfo>;
}
/**
 * 
 * @export
 * @interface ApiStakingPositionPeriods
 */
export interface ApiStakingPositionPeriods {
    /**
     * Period id, to be passed into protocol.
     * @type {number}
     * @memberof ApiStakingPositionPeriods
     */
    'period_id': number;
    /**
     * How much additional points will be accrued.
     * @type {number}
     * @memberof ApiStakingPositionPeriods
     */
    'percentage': number;
    /**
     * How much wait till position unlock.
     * @type {number}
     * @memberof ApiStakingPositionPeriods
     */
    'lock_duration': number;
}
/**
 * 
 * @export
 * @interface ApiStakingRewardsTokenInfo
 */
export interface ApiStakingRewardsTokenInfo {
    /**
     * Token address.
     * @type {string}
     * @memberof ApiStakingRewardsTokenInfo
     */
    'token_address': string;
    /**
     * Timestamp in unix seconds
     * @type {number}
     * @memberof ApiStakingRewardsTokenInfo
     */
    'end_distribution_unix': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingRewardsTokenInfo
     */
    'reward_rate': number;
}
/**
 * 
 * @export
 * @interface ApiStakingTokenInfo
 */
export interface ApiStakingTokenInfo {
    /**
     * Reward token address.
     * @type {string}
     * @memberof ApiStakingTokenInfo
     */
    'token_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingTokenInfo
     */
    'asset_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingTokenInfo
     */
    'asset_raw': number;
}
/**
 * 
 * @export
 * @interface ApiStakingTokenInfoLock
 */
export interface ApiStakingTokenInfoLock {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiStakingTokenInfoLock
     */
    'token': ApiToken;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingTokenInfoLock
     */
    'normalizer': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStakingTokenInfoLock
     */
    'price_per_token_usd': number;
}
/**
 * 
 * @export
 * @interface ApiStakingUserInfo
 */
export interface ApiStakingUserInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiStakingUserInfo
     */
    'total_points': number;
    /**
     * 
     * @type {Array<ApiStakingTokenInfo>}
     * @memberof ApiStakingUserInfo
     */
    'locked_tokens': Array<ApiStakingTokenInfo>;
    /**
     * 
     * @type {Array<ApiStakingTokenInfo>}
     * @memberof ApiStakingUserInfo
     */
    'paid_rewards': Array<ApiStakingTokenInfo>;
    /**
     * 
     * @type {Array<ApiStakingPositionInfo>}
     * @memberof ApiStakingUserInfo
     */
    'positions': Array<ApiStakingPositionInfo>;
}
/**
 * 
 * @export
 * @interface ApiStrategyOrder
 */
export interface ApiStrategyOrder {
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'id': number;
    /**
     * 
     * @type {ApiStrategyOrderType}
     * @memberof ApiStrategyOrder
     */
    'type': ApiStrategyOrderType;
    /**
     * 
     * @type {string}
     * @memberof ApiStrategyOrder
     */
    'wallet': string;
    /**
     * 
     * @type {ApiStrategyOrderStatus}
     * @memberof ApiStrategyOrder
     */
    'status': ApiStrategyOrderStatus;
    /**
     * Unix time in seconds
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'creation_timestamp': number;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiStrategyOrder
     */
    'token_from': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiStrategyOrder
     */
    'token_to': ApiToken;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'initial_input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'current_input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'min_output_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'current_output_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'max_suborders': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'suborders_executed': number;
    /**
     * Max amount of swaps to be potentially executed (including those that fail to reasons like slippage tolerance abortion)
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'max_invocations': number;
    /**
     * Amount of swaps that had already been tried to be executed (including those that failed to reasons like slippage tolerance abortion)
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'invocations_executed': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'slippage': number;
    /**
     * Max path length in tokens for every route that could potentially be executed within this order
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'max_path_length': number;
    /**
     * Amount of this order transactions that were sent, but their result is still unknown
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'active_transactions': number;
    /**
     * Unix time in seconds
     * @type {number}
     * @memberof ApiStrategyOrder
     */
    'close_timestamp'?: number;
}


/**
 * 
 * @export
 * @interface ApiStrategyOrderCreationRequest
 */
export interface ApiStrategyOrderCreationRequest {
    /**
     * 
     * @type {ApiStrategyOrderType}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'type': ApiStrategyOrderType;
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'token_from': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'token_to': ApiTokenAddress;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'min_output_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'max_suborders': number;
    /**
     * Max amount of swaps to be potentially executed (including those that fail to reasons like slippage tolerance abortion)
     * @type {number}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'max_invocations': number;
    /**
     * 
     * @type {number}
     * @memberof ApiStrategyOrderCreationRequest
     */
    'slippage': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiStrategyOrderStatus = {
    Active: 'active',
    RequestedCancellation: 'requested_cancellation',
    CancelledByUser: 'cancelled_by_user',
    CancelledBySystem: 'cancelled_by_system',
    Executed: 'executed',
    MaxRetriesExceeded: 'max_retries_exceeded'
} as const;

export type ApiStrategyOrderStatus = typeof ApiStrategyOrderStatus[keyof typeof ApiStrategyOrderStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiStrategyOrderType = {
    Limit: 'limit',
    Dca: 'dca',
    Vca: 'vca'
} as const;

export type ApiStrategyOrderType = typeof ApiStrategyOrderType[keyof typeof ApiStrategyOrderType];


/**
 * 
 * @export
 * @interface ApiSwap
 */
export interface ApiSwap {
    /**
     * 
     * @type {ApiSwapResult}
     * @memberof ApiSwap
     */
    'result': ApiSwapResult;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'output_amount': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'before_reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'after_reserves': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ApiSwap
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'left_amount'?: number;
}


/**
 * Result of the swap
 * @export
 * @enum {string}
 */

export const ApiSwapResult = {
    FullyFulfilled: 'fully_fulfilled',
    PartiallyFulfilled: 'partially_fulfilled',
    Unavailable: 'unavailable'
} as const;

export type ApiSwapResult = typeof ApiSwapResult[keyof typeof ApiSwapResult];


/**
 * 
 * @export
 * @interface ApiSwapTransaction
 */
export interface ApiSwapTransaction {
    /**
     * 
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'address': string;
    /**
     * Amount of nanotons to be sent. Can be passed to TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'value': string;
    /**
     * Base64-encoded cell. Treated as a payload field in TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'cell': string;
    /**
     * Internal message send mode. More: https://docs.ton.org/develop/smart-contracts/messages#message-modes
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'send_mode': number;
    /**
     * Unique identifier of the query used for tracking swap.coffee transactions among others
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'query_id': number;
}
/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiToken
     */
    'address': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenMetadata}
     * @memberof ApiToken
     */
    'metadata': ApiTokenMetadata;
}
/**
 * 
 * @export
 * @interface ApiTokenAddress
 */
export interface ApiTokenAddress {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface ApiTokenClaimRequest
 */
export interface ApiTokenClaimRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenClaimRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenClaimRequest
     */
    'token_address': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenClaimRequest
     */
    'wallet_address'?: string;
}
/**
 * 
 * @export
 * @interface ApiTokenClaimResponse
 */
export interface ApiTokenClaimResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenClaimResponse
     */
    'query_id': number;
    /**
     * 
     * @type {ApiTransactionBoc}
     * @memberof ApiTokenClaimResponse
     */
    'message': ApiTransactionBoc;
}
/**
 * 
 * @export
 * @interface ApiTokenMetadata
 */
export interface ApiTokenMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenMetadata
     */
    'decimals': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiTokenMetadata
     */
    'listed': boolean;
}
/**
 * 
 * @export
 * @interface ApiTokenRestrictions
 */
export interface ApiTokenRestrictions {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'min_swap_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'max_swap_amount'?: number;
}
/**
 * 
 * @export
 * @interface ApiTokenWithAmount
 */
export interface ApiTokenWithAmount {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiTokenWithAmount
     */
    'token': ApiToken;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenWithAmount
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiTonProof
 */
export interface ApiTonProof {
    /**
     * Valid till, in seconds
     * @type {number}
     * @memberof ApiTonProof
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof ApiTonProof
     */
    'domain_len': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'domain_val': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'payload': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface ApiTonStakingTransactionRequest
 */
export interface ApiTonStakingTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'referral_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'sender_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTonStakingTransactionRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'token_address': string;
}
/**
 * 
 * @export
 * @interface ApiTransactionBoc
 */
export interface ApiTransactionBoc {
    /**
     * Base64-encoded cell. Treated as a payload field in TonConnect transaction.
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'payload_cell': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'address': string;
    /**
     * Amount of nanotons to be sent. Can be passed to TonConnect transaction.
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'value': string;
    /**
     * Base64-encoded cell. Treated as a stateInit field in TonConnect transaction.
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'state_init'?: string;
}
/**
 * 
 * @export
 * @interface ApiTransactionResult
 */
export interface ApiTransactionResult {
    /**
     * 
     * @type {ApiTransactionStatus}
     * @memberof ApiTransactionResult
     */
    'status': ApiTransactionStatus;
    /**
     * 
     * @type {Array<ApiTransactionStepResult>}
     * @memberof ApiTransactionResult
     */
    'steps': Array<ApiTransactionStepResult>;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionResult
     */
    'input'?: ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionResult
     */
    'output'?: ApiQuantifiedToken;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStatus = {
    Pending: 'pending',
    PartiallyComplete: 'partially_complete',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStatus = typeof ApiTransactionStatus[keyof typeof ApiTransactionStatus];


/**
 * 
 * @export
 * @interface ApiTransactionStepResult
 */
export interface ApiTransactionStepResult {
    /**
     * 
     * @type {ApiTransactionStepStatus}
     * @memberof ApiTransactionStepResult
     */
    'status': ApiTransactionStepStatus;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionStepResult
     */
    'input'?: ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionStepResult
     */
    'output'?: ApiQuantifiedToken;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStepStatus = {
    Pending: 'pending',
    Cancelled: 'cancelled',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStepStatus = typeof ApiTransactionStepStatus[keyof typeof ApiTransactionStepStatus];


/**
 * 
 * @export
 * @interface ApiTransactionsRequest
 */
export interface ApiTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'sender_address': string;
    /**
     * If the slippage is exceeded, the transaction will not be executed and intermediate tokens will be returned to the sender.
     * @type {number}
     * @memberof ApiTransactionsRequest
     */
    'slippage': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'referral_name'?: string;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiTransactionsRequest
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiTransactionsResponse
 */
export interface ApiTransactionsResponse {
    /**
     * Unique identifier of the route used for tracking.
     * @type {number}
     * @memberof ApiTransactionsResponse
     */
    'route_id': number;
    /**
     * 
     * @type {Array<ApiSwapTransaction>}
     * @memberof ApiTransactionsResponse
     */
    'transactions': Array<ApiSwapTransaction>;
}
/**
 * 
 * @export
 * @interface ApiTxStats
 */
export interface ApiTxStats {
    /**
     * 
     * @type {number}
     * @memberof ApiTxStats
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ApiTxStats
     */
    'volume': number;
    /**
     * 
     * @type {number}
     * @memberof ApiTxStats
     */
    'fees': number;
}
/**
 * 
 * @export
 * @interface ApiUserCashbackInfo
 */
export interface ApiUserCashbackInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfo
     */
    'cashback_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfo
     */
    'earned_usd': number;
}
/**
 * 
 * @export
 * @interface ApiUserCashbackInfoTotal
 */
export interface ApiUserCashbackInfoTotal {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfoTotal
     */
    'cashback_count': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfoTotal
     */
    'total_earned_usd': number;
}
/**
 * 
 * @export
 * @interface ApiUserPoints
 */
export interface ApiUserPoints {
    /**
     * 
     * @type {number}
     * @memberof ApiUserPoints
     */
    'points': number;
}
/**
 * 
 * @export
 * @interface ApiUserStakeTokenInfo
 */
export interface ApiUserStakeTokenInfo {
    /**
     * Token address.
     * @type {string}
     * @memberof ApiUserStakeTokenInfo
     */
    'asset_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiUserStakeTokenInfo
     */
    'asset_amount_raw': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserStakeTokenInfo
     */
    'asset_amount_usd': number;
}
/**
 * 
 * @export
 * @interface ApiWithdrawal
 */
export interface ApiWithdrawal {
    /**
     * 
     * @type {ApiWithdrawalType}
     * @memberof ApiWithdrawal
     */
    'type': ApiWithdrawalType;
    /**
     * 
     * @type {ApiWithdrawalStatus}
     * @memberof ApiWithdrawal
     */
    'status': ApiWithdrawalStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiWithdrawalStatus = {
    Unhandled: 'unhandled',
    Processing: 'processing',
    Processed: 'processed'
} as const;

export type ApiWithdrawalStatus = typeof ApiWithdrawalStatus[keyof typeof ApiWithdrawalStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiWithdrawalType = {
    Repay: 'repay',
    Refund: 'refund'
} as const;

export type ApiWithdrawalType = typeof ApiWithdrawalType[keyof typeof ApiWithdrawalType];


/**
 * 
 * @export
 * @interface GetBlockchainsDefaultResponse
 */
export interface GetBlockchainsDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof GetBlockchainsDefaultResponse
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface GetWalletVersion200Response
 */
export interface GetWalletVersion200Response {
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'revision': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCreateAuthTokenRequest' is not null or undefined
            assertParamExists('createAuthToken', 'apiCreateAuthTokenRequest', apiCreateAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCreateAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteAuthToken', 'key', key)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken: async (apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiEditAuthTokenRequest' is not null or undefined
            assertParamExists('editAuthToken', 'apiEditAuthTokenRequest', apiEditAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiEditAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(apiCreateAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.createAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthToken(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthToken(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAuthToken(apiEditAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.editAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiAuthToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getAuthTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiAuthToken> {
            return localVarFp.createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken(key: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAuthToken(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiAuthToken> {
            return localVarFp.editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiAuthToken>> {
            return localVarFp.getAuthTokens(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Create new auth token
     * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete existing auth token
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteAuthToken(key: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteAuthToken(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing auth token
     * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing auth tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthTokens(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CashbackApi - axios parameter creator
 * @export
 */
export const CashbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new cashback distribution. For internal usage only
         * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashback: async (apiCashbackCreateRequest: ApiCashbackCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCashbackCreateRequest' is not null or undefined
            assertParamExists('createCashback', 'apiCashbackCreateRequest', apiCashbackCreateRequest)
            const localVarPath = `/v1/cashback/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCashbackCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashback info
         * @param {number} id Cashback id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfo: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCashbackInfo', 'id', id)
            const localVarPath = `/v1/cashback/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashbacks info
         * @param {string} [distributor] Address, from which, token will be distributed to participants
         * @param {string} [token] Cashback token
         * @param {boolean} [active] Filter out active promotions only
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfos: async (distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cashback/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (distributor !== undefined) {
                localVarQueryParameter['distributor'] = distributor;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashback promos rewards for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfo: async (address: string, xVerify: string, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getUserCashbackInfo', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getUserCashbackInfo', 'xVerify', xVerify)
            const localVarPath = `/v1/cashback/user/{address}/list`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashback total info for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfoTotal: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getUserCashbackInfoTotal', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getUserCashbackInfoTotal', 'xVerify', xVerify)
            const localVarPath = `/v1/cashback/user/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update cashback information. For internal usage only
         * @param {number} id Cashback id
         * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCashback: async (id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCashback', 'id', id)
            // verify required parameter 'apiCashbackUpdateRequest' is not null or undefined
            assertParamExists('updateCashback', 'apiCashbackUpdateRequest', apiCashbackUpdateRequest)
            const localVarPath = `/v1/cashback/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCashbackUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashbackApi - functional programming interface
 * @export
 */
export const CashbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new cashback distribution. For internal usage only
         * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCashback(apiCashbackCreateRequest: ApiCashbackCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCashback(apiCashbackCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.createCashback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashback info
         * @param {number} id Cashback id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashbackInfo(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashbackInfo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getCashbackInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashbacks info
         * @param {string} [distributor] Address, from which, token will be distributed to participants
         * @param {string} [token] Cashback token
         * @param {boolean} [active] Filter out active promotions only
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashbackInfos(distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashbackInfos(distributor, token, active, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getCashbackInfos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashback promos rewards for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCashbackInfo(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUserCashbackInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCashbackInfo(address, xVerify, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getUserCashbackInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashback total info for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCashbackInfoTotal(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserCashbackInfoTotal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCashbackInfoTotal(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getUserCashbackInfoTotal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update cashback information. For internal usage only
         * @param {number} id Cashback id
         * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCashback(id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCashback(id, apiCashbackUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.updateCashback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CashbackApi - factory interface
 * @export
 */
export const CashbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashbackApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new cashback distribution. For internal usage only
         * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashback(apiCashbackCreateRequest: ApiCashbackCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiCashbackInfo> {
            return localVarFp.createCashback(apiCashbackCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashback info
         * @param {number} id Cashback id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfo(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiCashbackInfo> {
            return localVarFp.getCashbackInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashbacks info
         * @param {string} [distributor] Address, from which, token will be distributed to participants
         * @param {string} [token] Cashback token
         * @param {boolean} [active] Filter out active promotions only
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfos(distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiCashbackInfoResponse> {
            return localVarFp.getCashbackInfos(distributor, token, active, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashback promos rewards for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfo(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiUserCashbackInfo>> {
            return localVarFp.getUserCashbackInfo(address, xVerify, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashback total info for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfoTotal(address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiUserCashbackInfoTotal> {
            return localVarFp.getUserCashbackInfoTotal(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update cashback information. For internal usage only
         * @param {number} id Cashback id
         * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCashback(id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiCashbackInfo> {
            return localVarFp.updateCashback(id, apiCashbackUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CashbackApi - object-oriented interface
 * @export
 * @class CashbackApi
 * @extends {BaseAPI}
 */
export class CashbackApi extends BaseAPI {
    /**
     * 
     * @summary Create new cashback distribution. For internal usage only
     * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public createCashback(apiCashbackCreateRequest: ApiCashbackCreateRequest, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).createCashback(apiCashbackCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashback info
     * @param {number} id Cashback id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getCashbackInfo(id: number, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getCashbackInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashbacks info
     * @param {string} [distributor] Address, from which, token will be distributed to participants
     * @param {string} [token] Cashback token
     * @param {boolean} [active] Filter out active promotions only
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getCashbackInfos(distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getCashbackInfos(distributor, token, active, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashback promos rewards for user
     * @param {string} address User address
     * @param {string} xVerify TON proof for the given address
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getUserCashbackInfo(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getUserCashbackInfo(address, xVerify, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashback total info for user
     * @param {string} address User address
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getUserCashbackInfoTotal(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getUserCashbackInfoTotal(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update cashback information. For internal usage only
     * @param {number} id Cashback id
     * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public updateCashback(id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).updateCashback(id, apiCashbackUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClaimApi - axios parameter creator
 * @export
 */
export const ClaimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimTokens: async (address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('claimTokens', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('claimTokens', 'xVerify', xVerify)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('claimTokens', 'type', type)
            // verify required parameter 'apiTokenClaimRequest' is not null or undefined
            assertParamExists('claimTokens', 'apiTokenClaimRequest', apiTokenClaimRequest)
            const localVarPath = `/v1/claim/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTokenClaimRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get state of account claimings
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountClaimingState: async (address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountClaimingState', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getAccountClaimingState', 'xVerify', xVerify)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getAccountClaimingState', 'type', type)
            const localVarPath = `/v1/claim/{address}/state`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s claiming stats
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingStats: async (address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getClaimingStats', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getClaimingStats', 'xVerify', xVerify)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getClaimingStats', 'type', type)
            const localVarPath = `/v1/claim/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get claiming transaction execution result
         * @param {Array<number>} queryId Public query ids to track withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingTransactionResult: async (queryId: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('getClaimingTransactionResult', 'queryId', queryId)
            const localVarPath = `/v1/claim/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (queryId) {
                localVarQueryParameter['query_id'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClaimApi - functional programming interface
 * @export
 */
export const ClaimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClaimApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimTokens(address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTokenClaimResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimTokens(address, xVerify, type, apiTokenClaimRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.claimTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get state of account claimings
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountClaimingState(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClaimStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountClaimingState(address, xVerify, type, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getAccountClaimingState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s claiming stats
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimingStats(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClaimingStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimingStats(address, xVerify, type, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getClaimingStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get claiming transaction execution result
         * @param {Array<number>} queryId Public query ids to track withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimingTransactionResult(queryId: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimingTransactionResult(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getClaimingTransactionResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClaimApi - factory interface
 * @export
 */
export const ClaimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClaimApiFp(configuration)
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimTokens(address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiTokenClaimResponse>> {
            return localVarFp.claimTokens(address, xVerify, type, apiTokenClaimRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get state of account claimings
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountClaimingState(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiClaimStateResponse> {
            return localVarFp.getAccountClaimingState(address, xVerify, type, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s claiming stats
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingStats(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiClaimingStats> {
            return localVarFp.getClaimingStats(address, xVerify, type, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get claiming transaction execution result
         * @param {Array<number>} queryId Public query ids to track withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingTransactionResult(queryId: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionStatus> {
            return localVarFp.getClaimingTransactionResult(queryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClaimApi - object-oriented interface
 * @export
 * @class ClaimApi
 * @extends {BaseAPI}
 */
export class ClaimApi extends BaseAPI {
    /**
     * 
     * @summary Claim tokens
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiClaimingType} type 
     * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public claimTokens(address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).claimTokens(address, xVerify, type, apiTokenClaimRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get state of account claimings
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiClaimingType} type 
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getAccountClaimingState(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getAccountClaimingState(address, xVerify, type, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s claiming stats
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiClaimingType} type 
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getClaimingStats(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getClaimingStats(address, xVerify, type, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get claiming transaction execution result
     * @param {Array<number>} queryId Public query ids to track withdraw request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getClaimingTransactionResult(queryId: Array<number>, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getClaimingTransactionResult(queryId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContestsApi - axios parameter creator
 * @export
 */
export const ContestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new contest. For internal usage only
         * @param {ApiContestInfo} apiContestInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContest: async (apiContestInfo: ApiContestInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiContestInfo' is not null or undefined
            assertParamExists('createContest', 'apiContestInfo', apiContestInfo)
            const localVarPath = `/v1/contests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiContestInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContest: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContest', 'id', id)
            const localVarPath = `/v1/contests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get top users\' stats for contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestTopUsersStats: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContestTopUsersStats', 'id', id)
            const localVarPath = `/v1/contests/{id}/top`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user stats for contest
         * @param {number} id 
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestUserStats: async (id: number, address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContestUserStats', 'id', id)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getContestUserStats', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getContestUserStats', 'xVerify', xVerify)
            const localVarPath = `/v1/contests/{id}/user/{address}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contests
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContests: async (active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing contest. For internal usage only
         * @param {number} id 
         * @param {ApiContestInfo} apiContestInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContest: async (id: number, apiContestInfo: ApiContestInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContest', 'id', id)
            // verify required parameter 'apiContestInfo' is not null or undefined
            assertParamExists('updateContest', 'apiContestInfo', apiContestInfo)
            const localVarPath = `/v1/contests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiContestInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContestsApi - functional programming interface
 * @export
 */
export const ContestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new contest. For internal usage only
         * @param {ApiContestInfo} apiContestInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContest(apiContestInfo: ApiContestInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiContestInfoWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContest(apiContestInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.createContest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContest(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiContestInfoWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContest(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get top users\' stats for contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContestTopUsersStats(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiContestUserStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContestTopUsersStats(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContestTopUsersStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user stats for contest
         * @param {number} id 
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContestUserStats(id: number, address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiContestUserStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContestUserStats(id, address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContestUserStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get contests
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContests(active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiContestInfoWithID>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContests(active, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing contest. For internal usage only
         * @param {number} id 
         * @param {ApiContestInfo} apiContestInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContest(id: number, apiContestInfo: ApiContestInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiContestInfoWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContest(id, apiContestInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.updateContest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContestsApi - factory interface
 * @export
 */
export const ContestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContestsApiFp(configuration)
    return {
        /**
         * Create new contest. For internal usage only
         * @param {ApiContestInfo} apiContestInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContest(apiContestInfo: ApiContestInfo, options?: RawAxiosRequestConfig): AxiosPromise<ApiContestInfoWithID> {
            return localVarFp.createContest(apiContestInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContest(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiContestInfoWithID> {
            return localVarFp.getContest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get top users\' stats for contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestTopUsersStats(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiContestUserStats>> {
            return localVarFp.getContestTopUsersStats(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user stats for contest
         * @param {number} id 
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestUserStats(id: number, address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiContestUserStats> {
            return localVarFp.getContestUserStats(id, address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contests
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContests(active?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiContestInfoWithID>> {
            return localVarFp.getContests(active, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing contest. For internal usage only
         * @param {number} id 
         * @param {ApiContestInfo} apiContestInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContest(id: number, apiContestInfo: ApiContestInfo, options?: RawAxiosRequestConfig): AxiosPromise<ApiContestInfoWithID> {
            return localVarFp.updateContest(id, apiContestInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContestsApi - object-oriented interface
 * @export
 * @class ContestsApi
 * @extends {BaseAPI}
 */
export class ContestsApi extends BaseAPI {
    /**
     * Create new contest. For internal usage only
     * @param {ApiContestInfo} apiContestInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public createContest(apiContestInfo: ApiContestInfo, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).createContest(apiContestInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contest
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContest(id: number, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get top users\' stats for contest
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContestTopUsersStats(id: number, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContestTopUsersStats(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user stats for contest
     * @param {number} id 
     * @param {string} address 
     * @param {string} xVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContestUserStats(id: number, address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContestUserStats(id, address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contests
     * @param {boolean} [active] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContests(active?: boolean, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContests(active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing contest. For internal usage only
     * @param {number} id 
     * @param {ApiContestInfo} apiContestInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public updateContest(id: number, apiContestInfo: ApiContestInfo, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).updateContest(id, apiContestInfo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/blockchains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex: async (blockchain: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getDex', 'blockchain', blockchain)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDex', 'name', name)
            const localVarPath = `/v1/dex/{blockchain}/{name}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes: async (blockchain?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getPool', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPool', 'address', address)
            const localVarPath = `/v1/pool/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getToken', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getToken', 'address', address)
            const localVarPath = `/v1/token/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (listed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (listed !== undefined) {
                localVarQueryParameter['listed'] = listed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol: async (blockchain: string, symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getTokensBySymbol', 'blockchain', blockchain)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTokensBySymbol', 'symbol', symbol)
            const localVarPath = `/v1/token/{blockchain}/by-symbol/{symbol}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockchains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiBlockchain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockchains(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getBlockchains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDex>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDex(blockchain, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDexes(blockchain?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiDex>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDexes(blockchain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDexes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(listed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(listed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokensBySymbol(blockchain, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokensBySymbol']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityApiFp(configuration)
    return {
        /**
         * 
         * @summary Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiBlockchain>> {
            return localVarFp.getBlockchains(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiDex> {
            return localVarFp.getDex(blockchain, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes(blockchain?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiDex>> {
            return localVarFp.getDexes(blockchain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiPool> {
            return localVarFp.getPool(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiToken> {
            return localVarFp.getToken(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(listed?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokens(listed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokensBySymbol(blockchain, symbol, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI {
    /**
     * 
     * @summary Get supported blockchains. Currently only TON is supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getBlockchains(options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getBlockchains(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given decentralized exchange for the given blockchain
     * @param {string} blockchain 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDex(blockchain, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
     * @param {string} [blockchain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDexes(blockchain?: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDexes(blockchain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given liquidity pool for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getPool(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given token for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getToken(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of tokens supported by the service
     * @param {boolean} [listed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokens(listed?: boolean, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokens(listed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given token by its symbol for the given blockchain
     * @param {string} blockchain 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokensBySymbol(blockchain, symbol, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnershipApi - axios parameter creator
 * @export
 */
export const PartnershipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
         * @param {string} address 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionRecords: async (address: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getRawTransactionRecords', 'address', address)
            const localVarPath = `/v1/partnership/{address}/transactions`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnershipApi - functional programming interface
 * @export
 */
export const PartnershipApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnershipApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
         * @param {string} address 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionRecords(address: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiRawTransactionRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawTransactionRecords(address, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnershipApi.getRawTransactionRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnershipApi - factory interface
 * @export
 */
export const PartnershipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnershipApiFp(configuration)
    return {
        /**
         * 
         * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
         * @param {string} address 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionRecords(address: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiRawTransactionRecord>> {
            return localVarFp.getRawTransactionRecords(address, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnershipApi - object-oriented interface
 * @export
 * @class PartnershipApi
 * @extends {BaseAPI}
 */
export class PartnershipApi extends BaseAPI {
    /**
     * 
     * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
     * @param {string} address 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnershipApi
     */
    public getRawTransactionRecords(address: string, page?: number, options?: RawAxiosRequestConfig) {
        return PartnershipApiFp(this.configuration).getRawTransactionRecords(address, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountSettings', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getAccountSettings', 'xVerify', xVerify)
            const localVarPath = `/v1/profile/{address}/settings`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTransactions: async (address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getHistoricalTransactions', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getHistoricalTransactions', 'xVerify', xVerify)
            const localVarPath = `/v1/profile/{address}/transactions`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (token2 !== undefined) {
                localVarQueryParameter['token2'] = token2;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettings: async (address: string, xVerify: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateAccountSettings', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('updateAccountSettings', 'xVerify', xVerify)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateAccountSettings', 'requestBody', requestBody)
            const localVarPath = `/v1/profile/{address}/settings`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProof: async (address: string, apiProofValidationRequest: ApiProofValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('validateProof', 'address', address)
            // verify required parameter 'apiProofValidationRequest' is not null or undefined
            assertParamExists('validateProof', 'apiProofValidationRequest', apiProofValidationRequest)
            const localVarPath = `/v1/profile/{address}/proof`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiProofValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSettings(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSettings(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiHistoricalTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTransactions(address, xVerify, token, token2, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getHistoricalTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountSettings(address, xVerify, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.updateAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateProof(address, apiProofValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.validateProof']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings(address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getAccountSettings(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiHistoricalTransaction>> {
            return localVarFp.getHistoricalTransactions(address, xVerify, token, token2, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAccountSettings(address, xVerify, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateProof(address, apiProofValidationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @summary Get account settings
     * @param {string} address 
     * @param {string} xVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getAccountSettings(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getAccountSettings(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get historical account transactions on swap.coffee
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {string} [token] If set, only transactions related to this token will be returned
     * @param {string} [token2] If set, only transactions related to this token pair will be returned
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getHistoricalTransactions(address, xVerify, token, token2, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account settings
     * @param {string} address 
     * @param {string} xVerify 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateAccountSettings(address, xVerify, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate TON proof for given account address
     * @param {string} address 
     * @param {ApiProofValidationRequest} apiProofValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).validateProof(address, apiProofValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralApi - axios parameter creator
 * @export
 */
export const ReferralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindReferral: async (address: string, referral: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('bindReferral', 'address', address)
            // verify required parameter 'referral' is not null or undefined
            assertParamExists('bindReferral', 'referral', referral)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('bindReferral', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (referral !== undefined) {
                localVarQueryParameter['referral'] = referral;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralInfo: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReferralInfo', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getReferralInfo', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralList: async (address: string, xVerify: string, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReferralList', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getReferralList', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}/list`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindReferral: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('unbindReferral', 'address', address)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update referral\'s info. For internal usage only.
         * @param {string} address 
         * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral: async (address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateReferral', 'address', address)
            // verify required parameter 'apiReferralAccountInfoUpdate' is not null or undefined
            assertParamExists('updateReferral', 'apiReferralAccountInfoUpdate', apiReferralAccountInfoUpdate)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiReferralAccountInfoUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralApi - functional programming interface
 * @export
 */
export const ReferralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindReferral(address: string, referral: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindReferral(address, referral, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.bindReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferralInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiReferralAccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferralInfo(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.getReferralInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferralList(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiReferralInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferralList(address, xVerify, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.getReferralList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindReferral(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindReferral(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.unbindReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update referral\'s info. For internal usage only.
         * @param {string} address 
         * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReferral(address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReferral(address, apiReferralAccountInfoUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.updateReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralApi - factory interface
 * @export
 */
export const ReferralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralApiFp(configuration)
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindReferral(address: string, referral: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bindReferral(address, referral, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiReferralAccountInfo> {
            return localVarFp.getReferralInfo(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralList(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiReferralInfo>> {
            return localVarFp.getReferralList(address, xVerify, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindReferral(address: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unbindReferral(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update referral\'s info. For internal usage only.
         * @param {string} address 
         * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral(address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateReferral(address, apiReferralAccountInfoUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralApi - object-oriented interface
 * @export
 * @class ReferralApi
 * @extends {BaseAPI}
 */
export class ReferralApi extends BaseAPI {
    /**
     * 
     * @summary Bind new referral
     * @param {string} address 
     * @param {string} referral 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public bindReferral(address: string, referral: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).bindReferral(address, referral, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s referral info
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public getReferralInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).getReferralInfo(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s list of referrals
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public getReferralList(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).getReferralList(address, xVerify, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unbind existing referral. For internal usage only.
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public unbindReferral(address: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).unbindReferral(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update referral\'s info. For internal usage only.
     * @param {string} address 
     * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public updateReferral(address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).updateReferral(address, apiReferralAccountInfoUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoutingApi - axios parameter creator
 * @export
 */
export const RoutingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute: async (apiRouteRequest: ApiRouteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiRouteRequest' is not null or undefined
            assertParamExists('buildRoute', 'apiRouteRequest', apiRouteRequest)
            const localVarPath = `/v1/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRouteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonStakeTransaction: async (apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTonStakingTransactionRequest' is not null or undefined
            assertParamExists('buildTonStakeTransaction', 'apiTonStakingTransactionRequest', apiTonStakingTransactionRequest)
            const localVarPath = `/v2/stake/ton/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTonStakingTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonUnstakeTransaction: async (apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTonStakingTransactionRequest' is not null or undefined
            assertParamExists('buildTonUnstakeTransaction', 'apiTonStakingTransactionRequest', apiTonStakingTransactionRequest)
            const localVarPath = `/v2/unstake/ton/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTonStakingTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2: async (apiTransactionsRequest: ApiTransactionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTransactionsRequest' is not null or undefined
            assertParamExists('buildTransactionsV2', 'apiTransactionsRequest', apiTransactionsRequest)
            const localVarPath = `/v2/route/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteResult: async (routeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routeId' is not null or undefined
            assertParamExists('getRouteResult', 'routeId', routeId)
            const localVarPath = `/v2/route/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (routeId !== undefined) {
                localVarQueryParameter['route_id'] = routeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getTransactionsResult: async (queryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('getTransactionsResult', 'queryId', queryId)
            const localVarPath = `/v1/route/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (queryId !== undefined) {
                localVarQueryParameter['query_id'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutingApi - functional programming interface
 * @export
 */
export const RoutingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoutingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildRoute(apiRouteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTonStakeTransaction(apiTonStakingTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTonStakeTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTonUnstakeTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTransactionsV2(apiTransactionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTransactionsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteResult(routeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiRouteResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteResult(routeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.getRouteResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTransactionResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsResult(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.getTransactionsResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoutingApi - factory interface
 * @export
 */
export const RoutingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutingApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiRoute> {
            return localVarFp.buildRoute(apiRouteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.buildTonStakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionsResponse> {
            return localVarFp.buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteResult(routeId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiRouteResult> {
            return localVarFp.getRouteResult(routeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiTransactionResult>> {
            return localVarFp.getTransactionsResult(queryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutingApi - object-oriented interface
 * @export
 * @class RoutingApi
 * @extends {BaseAPI}
 */
export class RoutingApi extends BaseAPI {
    /**
     * 
     * @summary Returns the best route for the given trade pair
     * @param {ApiRouteRequest} apiRouteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildRoute(apiRouteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
     * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTonStakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
     * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
     * @param {ApiTransactionsRequest} apiTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get route transactions execution result
     * @param {number} routeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public getRouteResult(routeId: number, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).getRouteResult(routeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get route transactions execution result
     * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).getTransactionsResult(queryId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StakingApi - axios parameter creator
 * @export
 */
export const StakingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Build transaction to close position and withdraw all money
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} id 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeStakingPosition: async (masterAddress: string, address: string, id: number, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'masterAddress' is not null or undefined
            assertParamExists('closeStakingPosition', 'masterAddress', masterAddress)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('closeStakingPosition', 'address', address)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('closeStakingPosition', 'id', id)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('closeStakingPosition', 'xVerify', xVerify)
            const localVarPath = `/v2/staking/{master_address}/positions/{address}/{id}`
                .replace(`{${"master_address"}}`, encodeURIComponent(String(masterAddress)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build transaction to create new staking position
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiCreateStakeRequest} apiCreateStakeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingPosition: async (masterAddress: string, address: string, xVerify: string, apiCreateStakeRequest: ApiCreateStakeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'masterAddress' is not null or undefined
            assertParamExists('createStakingPosition', 'masterAddress', masterAddress)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('createStakingPosition', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('createStakingPosition', 'xVerify', xVerify)
            // verify required parameter 'apiCreateStakeRequest' is not null or undefined
            assertParamExists('createStakingPosition', 'apiCreateStakeRequest', apiCreateStakeRequest)
            const localVarPath = `/v2/staking/{master_address}/positions/{address}`
                .replace(`{${"master_address"}}`, encodeURIComponent(String(masterAddress)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCreateStakeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build transaction to extend existing position
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} id 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiExtendStakeRequest} apiExtendStakeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendStakingPosition: async (masterAddress: string, address: string, id: number, xVerify: string, apiExtendStakeRequest: ApiExtendStakeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'masterAddress' is not null or undefined
            assertParamExists('extendStakingPosition', 'masterAddress', masterAddress)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('extendStakingPosition', 'address', address)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extendStakingPosition', 'id', id)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('extendStakingPosition', 'xVerify', xVerify)
            // verify required parameter 'apiExtendStakeRequest' is not null or undefined
            assertParamExists('extendStakingPosition', 'apiExtendStakeRequest', apiExtendStakeRequest)
            const localVarPath = `/v2/staking/{master_address}/positions/{address}/{id}`
                .replace(`{${"master_address"}}`, encodeURIComponent(String(masterAddress)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiExtendStakeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all stakings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStakings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/staking/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s staking points for CES
         * @param {string} address 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesPointsForUser: async (address: string, from?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getCesPointsForUser', 'address', address)
            const localVarPath = `/v1/staking/{address}/points`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get aggregated information about CES staking
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesStakingGlobalInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/staking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s balances of staked tokens in CES staking
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesStakingTokenBalances: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getCesStakingTokenBalances', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getCesStakingTokenBalances', 'xVerify', xVerify)
            const localVarPath = `/v1/staking/{address}/balances`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get aggregated information about CES staking for specific user
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesStakingUserInfo: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getCesStakingUserInfo', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getCesStakingUserInfo', 'xVerify', xVerify)
            const localVarPath = `/v1/staking/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s staking points
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointsForUser: async (masterAddress: string, address: string, from?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'masterAddress' is not null or undefined
            assertParamExists('getPointsForUser', 'masterAddress', masterAddress)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPointsForUser', 'address', address)
            const localVarPath = `/v2/staking/{master_address}/{address}/points`
                .replace(`{${"master_address"}}`, encodeURIComponent(String(masterAddress)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get aggregated information about staking
         * @param {string} masterAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingGlobalInfo: async (masterAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'masterAddress' is not null or undefined
            assertParamExists('getStakingGlobalInfo', 'masterAddress', masterAddress)
            const localVarPath = `/v2/staking/{master_address}`
                .replace(`{${"master_address"}}`, encodeURIComponent(String(masterAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s balances of staked tokens
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingTokenBalances: async (masterAddress: string, address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'masterAddress' is not null or undefined
            assertParamExists('getStakingTokenBalances', 'masterAddress', masterAddress)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStakingTokenBalances', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getStakingTokenBalances', 'xVerify', xVerify)
            const localVarPath = `/v2/staking/{master_address}/{address}/balances`
                .replace(`{${"master_address"}}`, encodeURIComponent(String(masterAddress)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get staking transaction execution result
         * @param {number} queryId Public query id to track staking process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingTransactionResult: async (queryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('getStakingTransactionResult', 'queryId', queryId)
            const localVarPath = `/v2/staking/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (queryId !== undefined) {
                localVarQueryParameter['query_id'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get aggregated information about staking for specific user
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingUserInfo: async (masterAddress: string, address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'masterAddress' is not null or undefined
            assertParamExists('getStakingUserInfo', 'masterAddress', masterAddress)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStakingUserInfo', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getStakingUserInfo', 'xVerify', xVerify)
            const localVarPath = `/v2/staking/{master_address}/{address}`
                .replace(`{${"master_address"}}`, encodeURIComponent(String(masterAddress)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StakingApi - functional programming interface
 * @export
 */
export const StakingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StakingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Build transaction to close position and withdraw all money
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} id 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeStakingPosition(masterAddress: string, address: string, id: number, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTokenClaimResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeStakingPosition(masterAddress, address, id, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.closeStakingPosition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Build transaction to create new staking position
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiCreateStakeRequest} apiCreateStakeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStakingPosition(masterAddress: string, address: string, xVerify: string, apiCreateStakeRequest: ApiCreateStakeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTokenClaimResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStakingPosition(masterAddress, address, xVerify, apiCreateStakeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.createStakingPosition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Build transaction to extend existing position
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} id 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiExtendStakeRequest} apiExtendStakeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extendStakingPosition(masterAddress: string, address: string, id: number, xVerify: string, apiExtendStakeRequest: ApiExtendStakeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTokenClaimResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extendStakingPosition(masterAddress, address, id, xVerify, apiExtendStakeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.extendStakingPosition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all stakings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStakings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiStakingInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllStakings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getAllStakings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s staking points for CES
         * @param {string} address 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCesPointsForUser(address: string, from?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserPoints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCesPointsForUser(address, from, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getCesPointsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get aggregated information about CES staking
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCesStakingGlobalInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiStakingGlobalInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCesStakingGlobalInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getCesStakingGlobalInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s balances of staked tokens in CES staking
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCesStakingTokenBalances(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUserStakeTokenInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCesStakingTokenBalances(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getCesStakingTokenBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get aggregated information about CES staking for specific user
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCesStakingUserInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiStakingUserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCesStakingUserInfo(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getCesStakingUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s staking points
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPointsForUser(masterAddress: string, address: string, from?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserPoints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPointsForUser(masterAddress, address, from, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getPointsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get aggregated information about staking
         * @param {string} masterAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingGlobalInfo(masterAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiStakingGlobalInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingGlobalInfo(masterAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getStakingGlobalInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s balances of staked tokens
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingTokenBalances(masterAddress: string, address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUserStakeTokenInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingTokenBalances(masterAddress, address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getStakingTokenBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get staking transaction execution result
         * @param {number} queryId Public query id to track staking process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingTransactionResult(queryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingTransactionResult(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getStakingTransactionResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get aggregated information about staking for specific user
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingUserInfo(masterAddress: string, address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiStakingUserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingUserInfo(masterAddress, address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StakingApi.getStakingUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StakingApi - factory interface
 * @export
 */
export const StakingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StakingApiFp(configuration)
    return {
        /**
         * 
         * @summary Build transaction to close position and withdraw all money
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} id 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeStakingPosition(masterAddress: string, address: string, id: number, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiTokenClaimResponse> {
            return localVarFp.closeStakingPosition(masterAddress, address, id, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build transaction to create new staking position
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiCreateStakeRequest} apiCreateStakeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingPosition(masterAddress: string, address: string, xVerify: string, apiCreateStakeRequest: ApiCreateStakeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiTokenClaimResponse> {
            return localVarFp.createStakingPosition(masterAddress, address, xVerify, apiCreateStakeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build transaction to extend existing position
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} id 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiExtendStakeRequest} apiExtendStakeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendStakingPosition(masterAddress: string, address: string, id: number, xVerify: string, apiExtendStakeRequest: ApiExtendStakeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiTokenClaimResponse> {
            return localVarFp.extendStakingPosition(masterAddress, address, id, xVerify, apiExtendStakeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all stakings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStakings(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiStakingInfo>> {
            return localVarFp.getAllStakings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s staking points for CES
         * @param {string} address 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesPointsForUser(address: string, from?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiUserPoints> {
            return localVarFp.getCesPointsForUser(address, from, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get aggregated information about CES staking
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesStakingGlobalInfo(options?: RawAxiosRequestConfig): AxiosPromise<ApiStakingGlobalInfo> {
            return localVarFp.getCesStakingGlobalInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s balances of staked tokens in CES staking
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesStakingTokenBalances(address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiUserStakeTokenInfo>> {
            return localVarFp.getCesStakingTokenBalances(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get aggregated information about CES staking for specific user
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCesStakingUserInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiStakingUserInfo> {
            return localVarFp.getCesStakingUserInfo(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s staking points
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointsForUser(masterAddress: string, address: string, from?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiUserPoints> {
            return localVarFp.getPointsForUser(masterAddress, address, from, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get aggregated information about staking
         * @param {string} masterAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingGlobalInfo(masterAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiStakingGlobalInfo> {
            return localVarFp.getStakingGlobalInfo(masterAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s balances of staked tokens
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingTokenBalances(masterAddress: string, address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiUserStakeTokenInfo>> {
            return localVarFp.getStakingTokenBalances(masterAddress, address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get staking transaction execution result
         * @param {number} queryId Public query id to track staking process
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingTransactionResult(queryId: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionStatus> {
            return localVarFp.getStakingTransactionResult(queryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get aggregated information about staking for specific user
         * @param {string} masterAddress 
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingUserInfo(masterAddress: string, address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiStakingUserInfo> {
            return localVarFp.getStakingUserInfo(masterAddress, address, xVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
export class StakingApi extends BaseAPI {
    /**
     * 
     * @summary Build transaction to close position and withdraw all money
     * @param {string} masterAddress 
     * @param {string} address 
     * @param {number} id 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public closeStakingPosition(masterAddress: string, address: string, id: number, xVerify: string, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).closeStakingPosition(masterAddress, address, id, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build transaction to create new staking position
     * @param {string} masterAddress 
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiCreateStakeRequest} apiCreateStakeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public createStakingPosition(masterAddress: string, address: string, xVerify: string, apiCreateStakeRequest: ApiCreateStakeRequest, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).createStakingPosition(masterAddress, address, xVerify, apiCreateStakeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build transaction to extend existing position
     * @param {string} masterAddress 
     * @param {string} address 
     * @param {number} id 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiExtendStakeRequest} apiExtendStakeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public extendStakingPosition(masterAddress: string, address: string, id: number, xVerify: string, apiExtendStakeRequest: ApiExtendStakeRequest, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).extendStakingPosition(masterAddress, address, id, xVerify, apiExtendStakeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all stakings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getAllStakings(options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getAllStakings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s staking points for CES
     * @param {string} address 
     * @param {number} [from] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getCesPointsForUser(address: string, from?: number, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getCesPointsForUser(address, from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get aggregated information about CES staking
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getCesStakingGlobalInfo(options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getCesStakingGlobalInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s balances of staked tokens in CES staking
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getCesStakingTokenBalances(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getCesStakingTokenBalances(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get aggregated information about CES staking for specific user
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getCesStakingUserInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getCesStakingUserInfo(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s staking points
     * @param {string} masterAddress 
     * @param {string} address 
     * @param {number} [from] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getPointsForUser(masterAddress: string, address: string, from?: number, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getPointsForUser(masterAddress, address, from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get aggregated information about staking
     * @param {string} masterAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getStakingGlobalInfo(masterAddress: string, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getStakingGlobalInfo(masterAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s balances of staked tokens
     * @param {string} masterAddress 
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getStakingTokenBalances(masterAddress: string, address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getStakingTokenBalances(masterAddress, address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get staking transaction execution result
     * @param {number} queryId Public query id to track staking process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getStakingTransactionResult(queryId: number, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getStakingTransactionResult(queryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get aggregated information about staking for specific user
     * @param {string} masterAddress 
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getStakingUserInfo(masterAddress: string, address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return StakingApiFp(this.configuration).getStakingUserInfo(masterAddress, address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatisticsApi - axios parameter creator
 * @export
 */
export const StatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get generic statistic of dex aggregation.
         * @param {number} from 
         * @param {number} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenericStats: async (from: number, to: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getGenericStats', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getGenericStats', 'to', to)
            const localVarPath = `/v1/statistics/generic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get generic statistic of dex aggregation.
         * @param {number} from 
         * @param {number} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenericStats(from: number, to: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTxStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenericStats(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatisticsApi.getGenericStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get generic statistic of dex aggregation.
         * @param {number} from 
         * @param {number} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenericStats(from: number, to: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiTxStats> {
            return localVarFp.getGenericStats(from, to, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
    /**
     * 
     * @summary Get generic statistic of dex aggregation.
     * @param {number} from 
     * @param {number} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public getGenericStats(from: number, to: number, options?: RawAxiosRequestConfig) {
        return StatisticsApiFp(this.configuration).getGenericStats(from, to, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StrategiesApi - axios parameter creator
 * @export
 */
export const StrategiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check whether strategies wallet exists for given account address.
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesStrategyWalletExist: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('doesStrategyWalletExist', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('doesStrategyWalletExist', 'xVerify', xVerify)
            const localVarPath = `/v1/strategies/{address}/wallet`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get strategy order
         * @param {string} address 
         * @param {string} xVerify 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrder: async (address: string, xVerify: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStrategyOrder', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getStrategyOrder', 'xVerify', xVerify)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStrategyOrder', 'id', id)
            const localVarPath = `/v1/strategies/{address}/order`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pre-built transaction for strategy order cancellation
         * @param {string} address 
         * @param {string} xVerify 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrderCancellationTransaction: async (address: string, xVerify: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStrategyOrderCancellationTransaction', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getStrategyOrderCancellationTransaction', 'xVerify', xVerify)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStrategyOrderCancellationTransaction', 'id', id)
            const localVarPath = `/v1/strategies/{address}/order`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pre-built transaction for strategy order creation
         * @param {string} address 
         * @param {string} xVerify 
         * @param {ApiStrategyOrderCreationRequest} apiStrategyOrderCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrderCreationTransaction: async (address: string, xVerify: string, apiStrategyOrderCreationRequest: ApiStrategyOrderCreationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStrategyOrderCreationTransaction', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getStrategyOrderCreationTransaction', 'xVerify', xVerify)
            // verify required parameter 'apiStrategyOrderCreationRequest' is not null or undefined
            assertParamExists('getStrategyOrderCreationTransaction', 'apiStrategyOrderCreationRequest', apiStrategyOrderCreationRequest)
            const localVarPath = `/v1/strategies/{address}/order`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiStrategyOrderCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get strategy orders
         * @param {string} address 
         * @param {string} xVerify 
         * @param {ApiStrategyOrderType} [type] 
         * @param {boolean} [includeFinished] By default, only active and pending cancellation orders are being returned
         * @param {number} [size] Maximum amount of results returned
         * @param {number} [beforeId] Return only those orders, which id is lower than the given one
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrders: async (address: string, xVerify: string, type?: ApiStrategyOrderType, includeFinished?: boolean, size?: number, beforeId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStrategyOrders', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getStrategyOrders', 'xVerify', xVerify)
            const localVarPath = `/v1/strategies/{address}/orders`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (includeFinished !== undefined) {
                localVarQueryParameter['include_finished'] = includeFinished;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['before_id'] = beforeId;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pre-built transaction for strategies wallet creation.
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyWalletCreationTransaction: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStrategyWalletCreationTransaction', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getStrategyWalletCreationTransaction', 'xVerify', xVerify)
            const localVarPath = `/v1/strategies/{address}/wallet`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StrategiesApi - functional programming interface
 * @export
 */
export const StrategiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StrategiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check whether strategies wallet exists for given account address.
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doesStrategyWalletExist(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doesStrategyWalletExist(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StrategiesApi.doesStrategyWalletExist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get strategy order
         * @param {string} address 
         * @param {string} xVerify 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyOrder(address: string, xVerify: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiStrategyOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStrategyOrder(address, xVerify, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StrategiesApi.getStrategyOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pre-built transaction for strategy order cancellation
         * @param {string} address 
         * @param {string} xVerify 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyOrderCancellationTransaction(address: string, xVerify: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStrategyOrderCancellationTransaction(address, xVerify, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StrategiesApi.getStrategyOrderCancellationTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pre-built transaction for strategy order creation
         * @param {string} address 
         * @param {string} xVerify 
         * @param {ApiStrategyOrderCreationRequest} apiStrategyOrderCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyOrderCreationTransaction(address: string, xVerify: string, apiStrategyOrderCreationRequest: ApiStrategyOrderCreationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStrategyOrderCreationTransaction(address, xVerify, apiStrategyOrderCreationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StrategiesApi.getStrategyOrderCreationTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get strategy orders
         * @param {string} address 
         * @param {string} xVerify 
         * @param {ApiStrategyOrderType} [type] 
         * @param {boolean} [includeFinished] By default, only active and pending cancellation orders are being returned
         * @param {number} [size] Maximum amount of results returned
         * @param {number} [beforeId] Return only those orders, which id is lower than the given one
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyOrders(address: string, xVerify: string, type?: ApiStrategyOrderType, includeFinished?: boolean, size?: number, beforeId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiStrategyOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStrategyOrders(address, xVerify, type, includeFinished, size, beforeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StrategiesApi.getStrategyOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pre-built transaction for strategies wallet creation.
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyWalletCreationTransaction(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStrategyWalletCreationTransaction(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StrategiesApi.getStrategyWalletCreationTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StrategiesApi - factory interface
 * @export
 */
export const StrategiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StrategiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Check whether strategies wallet exists for given account address.
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesStrategyWalletExist(address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.doesStrategyWalletExist(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get strategy order
         * @param {string} address 
         * @param {string} xVerify 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrder(address: string, xVerify: string, id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiStrategyOrder> {
            return localVarFp.getStrategyOrder(address, xVerify, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pre-built transaction for strategy order cancellation
         * @param {string} address 
         * @param {string} xVerify 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrderCancellationTransaction(address: string, xVerify: string, id: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.getStrategyOrderCancellationTransaction(address, xVerify, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pre-built transaction for strategy order creation
         * @param {string} address 
         * @param {string} xVerify 
         * @param {ApiStrategyOrderCreationRequest} apiStrategyOrderCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrderCreationTransaction(address: string, xVerify: string, apiStrategyOrderCreationRequest: ApiStrategyOrderCreationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.getStrategyOrderCreationTransaction(address, xVerify, apiStrategyOrderCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get strategy orders
         * @param {string} address 
         * @param {string} xVerify 
         * @param {ApiStrategyOrderType} [type] 
         * @param {boolean} [includeFinished] By default, only active and pending cancellation orders are being returned
         * @param {number} [size] Maximum amount of results returned
         * @param {number} [beforeId] Return only those orders, which id is lower than the given one
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyOrders(address: string, xVerify: string, type?: ApiStrategyOrderType, includeFinished?: boolean, size?: number, beforeId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiStrategyOrder>> {
            return localVarFp.getStrategyOrders(address, xVerify, type, includeFinished, size, beforeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pre-built transaction for strategies wallet creation.
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyWalletCreationTransaction(address: string, xVerify: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.getStrategyWalletCreationTransaction(address, xVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StrategiesApi - object-oriented interface
 * @export
 * @class StrategiesApi
 * @extends {BaseAPI}
 */
export class StrategiesApi extends BaseAPI {
    /**
     * 
     * @summary Check whether strategies wallet exists for given account address.
     * @param {string} address 
     * @param {string} xVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public doesStrategyWalletExist(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).doesStrategyWalletExist(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get strategy order
     * @param {string} address 
     * @param {string} xVerify 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public getStrategyOrder(address: string, xVerify: string, id: number, options?: RawAxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).getStrategyOrder(address, xVerify, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pre-built transaction for strategy order cancellation
     * @param {string} address 
     * @param {string} xVerify 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public getStrategyOrderCancellationTransaction(address: string, xVerify: string, id: number, options?: RawAxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).getStrategyOrderCancellationTransaction(address, xVerify, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pre-built transaction for strategy order creation
     * @param {string} address 
     * @param {string} xVerify 
     * @param {ApiStrategyOrderCreationRequest} apiStrategyOrderCreationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public getStrategyOrderCreationTransaction(address: string, xVerify: string, apiStrategyOrderCreationRequest: ApiStrategyOrderCreationRequest, options?: RawAxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).getStrategyOrderCreationTransaction(address, xVerify, apiStrategyOrderCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get strategy orders
     * @param {string} address 
     * @param {string} xVerify 
     * @param {ApiStrategyOrderType} [type] 
     * @param {boolean} [includeFinished] By default, only active and pending cancellation orders are being returned
     * @param {number} [size] Maximum amount of results returned
     * @param {number} [beforeId] Return only those orders, which id is lower than the given one
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public getStrategyOrders(address: string, xVerify: string, type?: ApiStrategyOrderType, includeFinished?: boolean, size?: number, beforeId?: number, options?: RawAxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).getStrategyOrders(address, xVerify, type, includeFinished, size, beforeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pre-built transaction for strategies wallet creation.
     * @param {string} address 
     * @param {string} xVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public getStrategyWalletCreationTransaction(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).getStrategyWalletCreationTransaction(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TonApi - axios parameter creator
 * @export
 */
export const TonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletBalance', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/balance`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletVersion', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/version`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TonApi - functional programming interface
 * @export
 */
export const TonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletBalance(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletVersion(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWalletVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletVersion(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TonApi - factory interface
 * @export
 */
export const TonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TonApiFp(configuration)
    return {
        /**
         * 
         * @summary Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance(address: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getWalletBalance(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion(address: string, options?: RawAxiosRequestConfig): AxiosPromise<GetWalletVersion200Response> {
            return localVarFp.getWalletVersion(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TonApi - object-oriented interface
 * @export
 * @class TonApi
 * @extends {BaseAPI}
 */
export class TonApi extends BaseAPI {
    /**
     * 
     * @summary Get wallet balance in nanotons (1e-9 TON)
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletBalance(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletBalance(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns wallet version and revision
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletVersion(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletVersion(address, options).then((request) => request(this.axios, this.basePath));
    }
}



