/* tslint:disable */
/* eslint-disable */
/**
 * Swap Coffee API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAmmType = {
    Volatile: 'volatile',
    Stable: 'stable'
} as const;

export type ApiAmmType = typeof ApiAmmType[keyof typeof ApiAmmType];


/**
 * 
 * @export
 * @interface ApiAuthToken
 */
export interface ApiAuthToken {
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiAuthToken
     */
    'administrative': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthToken
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiAuthToken
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAuthTokenOption = {
    AllowCycles: 'allow_cycles'
} as const;

export type ApiAuthTokenOption = typeof ApiAuthTokenOption[keyof typeof ApiAuthTokenOption];


/**
 * 
 * @export
 * @interface ApiBlockchain
 */
export interface ApiBlockchain {
    /**
     * 
     * @type {string}
     * @memberof ApiBlockchain
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiClaimStats
 */
export interface ApiClaimStats {
    /**
     * 
     * @type {ApiClaimType}
     * @memberof ApiClaimStats
     */
    'type': ApiClaimType;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStats
     */
    'claimed': number;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStats
     */
    'available': number;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStats
     */
    'locked': number;
}


/**
 * 
 * @export
 * @interface ApiClaimStatus
 */
export interface ApiClaimStatus {
    /**
     * 
     * @type {ApiClaimType}
     * @memberof ApiClaimStatus
     */
    'type': ApiClaimType;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStatus
     */
    'query_id': number;
    /**
     * When transaction happened in blockchain - unix seconds
     * @type {number}
     * @memberof ApiClaimStatus
     */
    'unix_time': number;
    /**
     * When transaction happened in blockchain - on-chain logical time
     * @type {number}
     * @memberof ApiClaimStatus
     */
    'logical_time': number;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimStatus
     */
    'transaction_hash': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimStatus
     */
    'token_address': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimStatus
     */
    'wallet_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStatus
     */
    'amount': number;
    /**
     * 
     * @type {ApiWithdrawal}
     * @memberof ApiClaimStatus
     */
    'withdrawal': ApiWithdrawal;
}


/**
 * 
 * @export
 * @interface ApiClaimStatusResponse
 */
export interface ApiClaimStatusResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStatusResponse
     */
    'total_count': number;
    /**
     * 
     * @type {Array<ApiClaimStatus>}
     * @memberof ApiClaimStatusResponse
     */
    'items': Array<ApiClaimStatus>;
}
/**
 * 
 * @export
 * @interface ApiClaimTokenStats
 */
export interface ApiClaimTokenStats {
    /**
     * 
     * @type {string}
     * @memberof ApiClaimTokenStats
     */
    'token_address': string;
    /**
     * Address of a wallet where token resides
     * @type {string}
     * @memberof ApiClaimTokenStats
     */
    'wallet_address': string;
    /**
     * 
     * @type {ApiClaimStats}
     * @memberof ApiClaimTokenStats
     */
    'stats': ApiClaimStats;
}
/**
 * 
 * @export
 * @interface ApiClaimTokenStatsResponse
 */
export interface ApiClaimTokenStatsResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiClaimTokenStatsResponse
     */
    'total_count': number;
    /**
     * 
     * @type {Array<ApiClaimTokenStats>}
     * @memberof ApiClaimTokenStatsResponse
     */
    'items': Array<ApiClaimTokenStats>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiClaimType = {
    All: 'all',
    Referral: 'referral'
} as const;

export type ApiClaimType = typeof ApiClaimType[keyof typeof ApiClaimType];


/**
 * 
 * @export
 * @interface ApiCreateAuthTokenRequest
 */
export interface ApiCreateAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCreateAuthTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiCreateAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiCreateAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiDex
 */
export interface ApiDex {
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiEditAuthTokenRequest
 */
export interface ApiEditAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiEditAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiEditAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface ApiHistoricalTransaction
 */
export interface ApiHistoricalTransaction {
    /**
     * 
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'route_id': number;
    /**
     * When transaction happened in blockchain - unix seconds
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'unix_time': number;
    /**
     * When transaction happened in blockchain - on-chain logical time
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'logical_time': number;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiHistoricalTransaction
     */
    'from': ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiHistoricalTransaction
     */
    'to': ApiQuantifiedToken;
    /**
     * 
     * @type {string}
     * @memberof ApiHistoricalTransaction
     */
    'dex': string;
}
/**
 * 
 * @export
 * @interface ApiPool
 */
export interface ApiPool {
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'address': string;
    /**
     * 
     * @type {ApiPoolType}
     * @memberof ApiPool
     */
    'type': ApiPoolType;
    /**
     * 
     * @type {ApiAmmType}
     * @memberof ApiPool
     */
    'amm_type': ApiAmmType;
    /**
     * 
     * @type {Array<ApiToken>}
     * @memberof ApiPool
     */
    'tokens': Array<ApiToken>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'extra_decimals'?: Array<number>;
    /**
     * 
     * @type {Array<ApiTokenRestrictions>}
     * @memberof ApiPool
     */
    'restrictions'?: Array<ApiTokenRestrictions>;
    /**
     * 
     * @type {ApiPoolFees}
     * @memberof ApiPool
     */
    'fees': ApiPoolFees;
}


/**
 * 
 * @export
 * @interface ApiPoolFees
 */
export interface ApiPoolFees {
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'average_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'divider'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'input'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'output'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'first_token'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'second_token'?: number;
}
/**
 * Configures the DEX pools that can appear in the generated route. By setting blockchains = [\"ton\"] inside it, you can remove the dexes field; max_volatility allows you to exclude pools whose volatility has been above a certain percentage in the last 15 minutes. This makes sense when you allow 2-3 intermediate tokens or a large number of splits to smooth out potential issues.
 * @export
 * @interface ApiPoolSelector
 */
export interface ApiPoolSelector {
    /**
     * If specified, only pools from given blockchains will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'blockchains'?: Array<string>;
    /**
     * If specified, only pools from given dexes will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'dexes'?: Array<string>;
    /**
     * If specified, only pools with volatility lower than given value will be used for routing
     * @type {number}
     * @memberof ApiPoolSelector
     */
    'max_volatility'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiPoolType = {
    Public: 'public',
    Private: 'private',
    Slumbering: 'slumbering',
    Invalid: 'invalid'
} as const;

export type ApiPoolType = typeof ApiPoolType[keyof typeof ApiPoolType];


/**
 * 
 * @export
 * @interface ApiProofValidationRequest
 */
export interface ApiProofValidationRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiProofValidationRequest
     */
    'public_key': string;
    /**
     * Base64-encoded initial state. Must be retrieved from ton-connect.
     * @type {string}
     * @memberof ApiProofValidationRequest
     */
    'wallet_state_init': string;
    /**
     * 
     * @type {ApiTonProof}
     * @memberof ApiProofValidationRequest
     */
    'proof': ApiTonProof;
}
/**
 * 
 * @export
 * @interface ApiQuantifiedToken
 */
export interface ApiQuantifiedToken {
    /**
     * 
     * @type {string}
     * @memberof ApiQuantifiedToken
     */
    'token_blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiQuantifiedToken
     */
    'token_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiQuantifiedToken
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiRecommendedGas
 */
export interface ApiRecommendedGas {
    /**
     * 
     * @type {string}
     * @memberof ApiRecommendedGas
     */
    'blockchain': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRecommendedGas
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountInfo
 */
export interface ApiReferralAccountInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiReferralAccountInfo
     */
    'link': string;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'fees_percentage': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'referrals_count': number;
    /**
     * Number of transactions sent by referral users
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'transactions_count': number;
    /**
     * 
     * @type {ApiReferralAccountRewards}
     * @memberof ApiReferralAccountInfo
     */
    'rewards': ApiReferralAccountRewards;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountReward
 */
export interface ApiReferralAccountReward {
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountReward
     */
    'volume': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountReward
     */
    'fees': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountRewards
 */
export interface ApiReferralAccountRewards {
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralAccountRewards
     */
    'monthly': ApiReferralAccountReward;
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralAccountRewards
     */
    'total': ApiReferralAccountReward;
}
/**
 * 
 * @export
 * @interface ApiReferralInfo
 */
export interface ApiReferralInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiReferralInfo
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralInfo
     */
    'transactions_count': number;
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralInfo
     */
    'rewards': ApiReferralAccountReward;
}
/**
 * 
 * @export
 * @interface ApiRoute
 */
export interface ApiRoute {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'savings'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'left_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'recommended_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'price_impact': number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoute
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiRouteRequest
 */
export interface ApiRouteRequest {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'input_token': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'output_token': ApiTokenAddress;
    /**
     * Input amount in tokens (not nano!) to be swapped
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'input_amount'?: number;
    /**
     * If specified, the route will be built to get the specified output amount. If not specified, the route will be built to get the maximum output amount for the given input amount.
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'output_amount'?: number;
    /**
     * Defines the maximum number of independent paths (i.e., transactions) the route can split into. For v4 wallets, you can omit this or set it to 4; for v5 wallets, you can set it to 20 (this is our internal upper limit, and we may reduce it to 10).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_splits'?: number;
    /**
     * Defines the maximum length of each path in tokens. It accepts values from [2; 5]. If it\'s 2, only direct swaps A -> B without multihops are possible. If it\'s 3, there can be a maximum of 1 intermediate token, i.e., A -> X -> B. If it\'s 4/5, there can be 2/3 intermediate tokens. A value of 2 deprives you of more profitable exchanges by finding market inefficiencies and does not allow you to exchange tokens without a direct pair (since there can be no intermediate tokens). The higher the value, the more profitable routes can be built, but the higher the likelihood that the user ends up with an intermediate token (since our blockchain is asynchronous, and some swap in the middle of the route may fail due to slippage).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_length'?: number;
    /**
     * 
     * @type {ApiPoolSelector}
     * @memberof ApiRouteRequest
     */
    'pool_selector'?: ApiPoolSelector;
}
/**
 * 
 * @export
 * @interface ApiRoutingStep
 */
export interface ApiRoutingStep {
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'pool_address': string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {ApiSwap}
     * @memberof ApiRoutingStep
     */
    'swap': ApiSwap;
    /**
     * 
     * @type {number}
     * @memberof ApiRoutingStep
     */
    'recommended_gas': number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoutingStep
     */
    'next'?: Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiSwap
 */
export interface ApiSwap {
    /**
     * 
     * @type {ApiSwapResult}
     * @memberof ApiSwap
     */
    'result': ApiSwapResult;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'output_amount': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'before_reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'after_reserves': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ApiSwap
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'left_amount'?: number;
}


/**
 * Result of the swap
 * @export
 * @enum {string}
 */

export const ApiSwapResult = {
    FullyFulfilled: 'fully_fulfilled',
    PartiallyFulfilled: 'partially_fulfilled',
    Unavailable: 'unavailable'
} as const;

export type ApiSwapResult = typeof ApiSwapResult[keyof typeof ApiSwapResult];


/**
 * 
 * @export
 * @interface ApiSwapTransaction
 */
export interface ApiSwapTransaction {
    /**
     * 
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'address': string;
    /**
     * Amount of nanotons to be sent. Can be passed to TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'value': string;
    /**
     * Base64-encoded cell. Treated as a payload field in TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'cell': string;
    /**
     * Internal message send mode. More: https://docs.ton.org/develop/smart-contracts/messages#message-modes
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'send_mode': number;
    /**
     * Unique identifier of the query used for tracking swap.coffee transactions among others
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'query_id': number;
}
/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiToken
     */
    'address': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenMetadata}
     * @memberof ApiToken
     */
    'metadata': ApiTokenMetadata;
}
/**
 * 
 * @export
 * @interface ApiTokenAddress
 */
export interface ApiTokenAddress {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface ApiTokenClaimRequest
 */
export interface ApiTokenClaimRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenClaimRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenClaimRequest
     */
    'token_address': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenClaimRequest
     */
    'wallet_address'?: string;
}
/**
 * 
 * @export
 * @interface ApiTokenMetadata
 */
export interface ApiTokenMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenMetadata
     */
    'decimals': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiTokenMetadata
     */
    'listed': boolean;
}
/**
 * 
 * @export
 * @interface ApiTokenRestrictions
 */
export interface ApiTokenRestrictions {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'min_swap_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'max_swap_amount'?: number;
}
/**
 * 
 * @export
 * @interface ApiTonProof
 */
export interface ApiTonProof {
    /**
     * Valid till, in seconds
     * @type {number}
     * @memberof ApiTonProof
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof ApiTonProof
     */
    'domain_len': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'domain_val': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'payload': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface ApiTonStakingTransactionRequest
 */
export interface ApiTonStakingTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'referral_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'sender_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTonStakingTransactionRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'token_address': string;
}
/**
 * 
 * @export
 * @interface ApiTransactionBoc
 */
export interface ApiTransactionBoc {
    /**
     * Base64-encoded cell. Treated as a payload field in TonConnect transaction.
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'payload_cell': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'address': string;
    /**
     * Amount of nanotons to be sent. Can be passed to TonConnect transaction.
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ApiTransactionResult
 */
export interface ApiTransactionResult {
    /**
     * 
     * @type {ApiTransactionStatus}
     * @memberof ApiTransactionResult
     */
    'status': ApiTransactionStatus;
    /**
     * 
     * @type {Array<ApiTransactionStepResult>}
     * @memberof ApiTransactionResult
     */
    'steps': Array<ApiTransactionStepResult>;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionResult
     */
    'input'?: ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionResult
     */
    'output'?: ApiQuantifiedToken;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStatus = {
    Pending: 'pending',
    PartiallyComplete: 'partially_complete',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStatus = typeof ApiTransactionStatus[keyof typeof ApiTransactionStatus];


/**
 * 
 * @export
 * @interface ApiTransactionStepResult
 */
export interface ApiTransactionStepResult {
    /**
     * 
     * @type {ApiTransactionStepStatus}
     * @memberof ApiTransactionStepResult
     */
    'status': ApiTransactionStepStatus;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionStepResult
     */
    'input'?: ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionStepResult
     */
    'output'?: ApiQuantifiedToken;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStepStatus = {
    Pending: 'pending',
    Cancelled: 'cancelled',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStepStatus = typeof ApiTransactionStepStatus[keyof typeof ApiTransactionStepStatus];


/**
 * 
 * @export
 * @interface ApiTransactionsRequest
 */
export interface ApiTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'sender_address': string;
    /**
     * Slippage in fractions (1 = 100%, 0 = 0%). If the slippage is exceeded, the transaction will not be executed and intermediate tokens will be returned to the sender.
     * @type {number}
     * @memberof ApiTransactionsRequest
     */
    'slippage': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'referral_name'?: string;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiTransactionsRequest
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiTransactionsResponse
 */
export interface ApiTransactionsResponse {
    /**
     * Unique identifier of the route used for tracking.
     * @type {number}
     * @memberof ApiTransactionsResponse
     */
    'route_id': number;
    /**
     * 
     * @type {Array<ApiSwapTransaction>}
     * @memberof ApiTransactionsResponse
     */
    'transactions': Array<ApiSwapTransaction>;
}
/**
 * 
 * @export
 * @interface ApiWithdrawal
 */
export interface ApiWithdrawal {
    /**
     * 
     * @type {ApiWithdrawalType}
     * @memberof ApiWithdrawal
     */
    'type': ApiWithdrawalType;
    /**
     * 
     * @type {ApiWithdrawalStatus}
     * @memberof ApiWithdrawal
     */
    'status': ApiWithdrawalStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiWithdrawalStatus = {
    Unhandled: 'unhandled',
    Processing: 'processing',
    Processed: 'processed'
} as const;

export type ApiWithdrawalStatus = typeof ApiWithdrawalStatus[keyof typeof ApiWithdrawalStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiWithdrawalType = {
    Repay: 'repay',
    Refund: 'refund'
} as const;

export type ApiWithdrawalType = typeof ApiWithdrawalType[keyof typeof ApiWithdrawalType];


/**
 * 
 * @export
 * @interface GetBlockchainsDefaultResponse
 */
export interface GetBlockchainsDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof GetBlockchainsDefaultResponse
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface GetWalletVersion200Response
 */
export interface GetWalletVersion200Response {
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'revision': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCreateAuthTokenRequest' is not null or undefined
            assertParamExists('createAuthToken', 'apiCreateAuthTokenRequest', apiCreateAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCreateAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteAuthToken', 'key', key)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken: async (apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiEditAuthTokenRequest' is not null or undefined
            assertParamExists('editAuthToken', 'apiEditAuthTokenRequest', apiEditAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiEditAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(apiCreateAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.createAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthToken(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthToken(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAuthToken(apiEditAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.editAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiAuthToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getAuthTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: any): AxiosPromise<ApiAuthToken> {
            return localVarFp.createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken(key: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAuthToken(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: any): AxiosPromise<ApiAuthToken> {
            return localVarFp.editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens(options?: any): AxiosPromise<Array<ApiAuthToken>> {
            return localVarFp.getAuthTokens(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Create new auth token
     * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete existing auth token
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteAuthToken(key: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteAuthToken(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit existing auth token
     * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing auth tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthTokens(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClaimApi - axios parameter creator
 * @export
 */
export const ClaimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimTokens: async (address: string, type: ApiClaimType, xVerify: string, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('claimTokens', 'address', address)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('claimTokens', 'type', type)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('claimTokens', 'xVerify', xVerify)
            // verify required parameter 'apiTokenClaimRequest' is not null or undefined
            assertParamExists('claimTokens', 'apiTokenClaimRequest', apiTokenClaimRequest)
            const localVarPath = `/v1/claim/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTokenClaimRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s aggregated claiming stats
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimStatsAggregated: async (address: string, type: ApiClaimType, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getClaimStatsAggregated', 'address', address)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getClaimStatsAggregated', 'type', type)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getClaimStatsAggregated', 'xVerify', xVerify)
            const localVarPath = `/v1/claim/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s claiming stats per token
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimStatsPerToken: async (address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getClaimStatsPerToken', 'address', address)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getClaimStatsPerToken', 'type', type)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getClaimStatsPerToken', 'xVerify', xVerify)
            const localVarPath = `/v1/claim/{address}/tokens`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status of account claimings
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimStatus: async (address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getClaimStatus', 'address', address)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getClaimStatus', 'type', type)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getClaimStatus', 'xVerify', xVerify)
            const localVarPath = `/v1/claim/{address}/status`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClaimApi - functional programming interface
 * @export
 */
export const ClaimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClaimApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimTokens(address: string, type: ApiClaimType, xVerify: string, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTransactionBoc>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimTokens(address, type, xVerify, apiTokenClaimRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.claimTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s aggregated claiming stats
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimStatsAggregated(address: string, type: ApiClaimType, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiClaimStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimStatsAggregated(address, type, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getClaimStatsAggregated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s claiming stats per token
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimStatsPerToken(address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClaimTokenStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimStatsPerToken(address, type, xVerify, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getClaimStatsPerToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get status of account claimings
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimStatus(address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClaimStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimStatus(address, type, xVerify, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getClaimStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClaimApi - factory interface
 * @export
 */
export const ClaimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClaimApiFp(configuration)
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimTokens(address: string, type: ApiClaimType, xVerify: string, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: any): AxiosPromise<Array<ApiTransactionBoc>> {
            return localVarFp.claimTokens(address, type, xVerify, apiTokenClaimRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s aggregated claiming stats
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimStatsAggregated(address: string, type: ApiClaimType, xVerify: string, options?: any): AxiosPromise<Array<ApiClaimStats>> {
            return localVarFp.getClaimStatsAggregated(address, type, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s claiming stats per token
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimStatsPerToken(address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options?: any): AxiosPromise<ApiClaimTokenStatsResponse> {
            return localVarFp.getClaimStatsPerToken(address, type, xVerify, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status of account claimings
         * @param {string} address 
         * @param {ApiClaimType} type 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimStatus(address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options?: any): AxiosPromise<ApiClaimStatusResponse> {
            return localVarFp.getClaimStatus(address, type, xVerify, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClaimApi - object-oriented interface
 * @export
 * @class ClaimApi
 * @extends {BaseAPI}
 */
export class ClaimApi extends BaseAPI {
    /**
     * 
     * @summary Claim tokens
     * @param {string} address 
     * @param {ApiClaimType} type 
     * @param {string} xVerify TON proof for the given address
     * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public claimTokens(address: string, type: ApiClaimType, xVerify: string, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).claimTokens(address, type, xVerify, apiTokenClaimRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s aggregated claiming stats
     * @param {string} address 
     * @param {ApiClaimType} type 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getClaimStatsAggregated(address: string, type: ApiClaimType, xVerify: string, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getClaimStatsAggregated(address, type, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s claiming stats per token
     * @param {string} address 
     * @param {ApiClaimType} type 
     * @param {string} xVerify TON proof for the given address
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getClaimStatsPerToken(address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getClaimStatsPerToken(address, type, xVerify, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status of account claimings
     * @param {string} address 
     * @param {ApiClaimType} type 
     * @param {string} xVerify TON proof for the given address
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getClaimStatus(address: string, type: ApiClaimType, xVerify: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getClaimStatus(address, type, xVerify, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/blockchains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex: async (blockchain: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getDex', 'blockchain', blockchain)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDex', 'name', name)
            const localVarPath = `/v1/dex/{blockchain}/{name}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes: async (blockchain?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getPool', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPool', 'address', address)
            const localVarPath = `/v1/pool/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getToken', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getToken', 'address', address)
            const localVarPath = `/v1/token/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (listed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (listed !== undefined) {
                localVarQueryParameter['listed'] = listed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol: async (blockchain: string, symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getTokensBySymbol', 'blockchain', blockchain)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTokensBySymbol', 'symbol', symbol)
            const localVarPath = `/v1/token/{blockchain}/by-symbol/{symbol}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration)
    return {
        /**
         * Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockchains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiBlockchain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockchains(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getBlockchains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDex>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDex(blockchain, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDexes(blockchain?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiDex>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDexes(blockchain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDexes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(listed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(listed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokensBySymbol(blockchain, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokensBySymbol']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityApiFp(configuration)
    return {
        /**
         * Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains(options?: any): AxiosPromise<Array<ApiBlockchain>> {
            return localVarFp.getBlockchains(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex(blockchain: string, name: string, options?: any): AxiosPromise<ApiDex> {
            return localVarFp.getDex(blockchain, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes(blockchain?: string, options?: any): AxiosPromise<Array<ApiDex>> {
            return localVarFp.getDexes(blockchain, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(blockchain: string, address: string, options?: any): AxiosPromise<ApiPool> {
            return localVarFp.getPool(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(blockchain: string, address: string, options?: any): AxiosPromise<ApiToken> {
            return localVarFp.getToken(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(listed?: boolean, options?: any): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokens(listed, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol(blockchain: string, symbol: string, options?: any): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokensBySymbol(blockchain, symbol, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI {
    /**
     * Get supported blockchains. Currently only TON is supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getBlockchains(options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getBlockchains(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given decentralized exchange for the given blockchain
     * @param {string} blockchain 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDex(blockchain, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of supported decentralized exchanges supported by the service in the given blockchain
     * @param {string} [blockchain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDexes(blockchain?: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDexes(blockchain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given liquidity pool for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getPool(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given token for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getToken(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of tokens supported by the service
     * @param {boolean} [listed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokens(listed?: boolean, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokens(listed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the given token by its symbol for the given blockchain
     * @param {string} blockchain 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokensBySymbol(blockchain, symbol, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountSettings', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getAccountSettings', 'xVerify', xVerify)
            const localVarPath = `/v1/profile/{address}/settings`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x_verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTransactions: async (address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getHistoricalTransactions', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getHistoricalTransactions', 'xVerify', xVerify)
            const localVarPath = `/v1/profile/{address}/transactions`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (token2 !== undefined) {
                localVarQueryParameter['token2'] = token2;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettings: async (address: string, xVerify: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateAccountSettings', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('updateAccountSettings', 'xVerify', xVerify)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateAccountSettings', 'requestBody', requestBody)
            const localVarPath = `/v1/profile/{address}/settings`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x_verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProof: async (address: string, apiProofValidationRequest: ApiProofValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('validateProof', 'address', address)
            // verify required parameter 'apiProofValidationRequest' is not null or undefined
            assertParamExists('validateProof', 'apiProofValidationRequest', apiProofValidationRequest)
            const localVarPath = `/v1/profile/{address}/proof`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiProofValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSettings(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSettings(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiHistoricalTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTransactions(address, xVerify, token, token2, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getHistoricalTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountSettings(address, xVerify, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.updateAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateProof(address, apiProofValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.validateProof']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings(address: string, xVerify: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getAccountSettings(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: any): AxiosPromise<Array<ApiHistoricalTransaction>> {
            return localVarFp.getHistoricalTransactions(address, xVerify, token, token2, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<void> {
            return localVarFp.updateAccountSettings(address, xVerify, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.validateProof(address, apiProofValidationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Get account settings
     * @param {string} address 
     * @param {string} xVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getAccountSettings(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getAccountSettings(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get historical account transactions on swap.coffee
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {string} [token] If set, only transactions related to this token will be returned
     * @param {string} [token2] If set, only transactions related to this token pair will be returned
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getHistoricalTransactions(address, xVerify, token, token2, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update account settings
     * @param {string} address 
     * @param {string} xVerify 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateAccountSettings(address, xVerify, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate TON proof for given account address
     * @param {string} address 
     * @param {ApiProofValidationRequest} apiProofValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).validateProof(address, apiProofValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralApi - axios parameter creator
 * @export
 */
export const ReferralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindReferral: async (address: string, referral: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('bindReferral', 'address', address)
            // verify required parameter 'referral' is not null or undefined
            assertParamExists('bindReferral', 'referral', referral)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('bindReferral', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (referral !== undefined) {
                localVarQueryParameter['referral'] = referral;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralInfo: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReferralInfo', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getReferralInfo', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralList: async (address: string, xVerify: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReferralList', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getReferralList', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}/list`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindReferral: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('unbindReferral', 'address', address)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralApi - functional programming interface
 * @export
 */
export const ReferralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindReferral(address: string, referral: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindReferral(address, referral, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.bindReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferralInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiReferralAccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferralInfo(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.getReferralInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferralList(address: string, xVerify: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiReferralInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferralList(address, xVerify, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.getReferralList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindReferral(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindReferral(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.unbindReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralApi - factory interface
 * @export
 */
export const ReferralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralApiFp(configuration)
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindReferral(address: string, referral: string, xVerify: string, options?: any): AxiosPromise<void> {
            return localVarFp.bindReferral(address, referral, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralInfo(address: string, xVerify: string, options?: any): AxiosPromise<ApiReferralAccountInfo> {
            return localVarFp.getReferralInfo(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralList(address: string, xVerify: string, offset?: number, limit?: number, options?: any): AxiosPromise<Array<ApiReferralInfo>> {
            return localVarFp.getReferralList(address, xVerify, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindReferral(address: string, options?: any): AxiosPromise<void> {
            return localVarFp.unbindReferral(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralApi - object-oriented interface
 * @export
 * @class ReferralApi
 * @extends {BaseAPI}
 */
export class ReferralApi extends BaseAPI {
    /**
     * 
     * @summary Bind new referral
     * @param {string} address 
     * @param {string} referral 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public bindReferral(address: string, referral: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).bindReferral(address, referral, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s referral info
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public getReferralInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).getReferralInfo(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s list of referrals
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public getReferralList(address: string, xVerify: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).getReferralList(address, xVerify, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unbind existing referral. For internal usage only.
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public unbindReferral(address: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).unbindReferral(address, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoutingApi - axios parameter creator
 * @export
 */
export const RoutingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute: async (apiRouteRequest: ApiRouteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiRouteRequest' is not null or undefined
            assertParamExists('buildRoute', 'apiRouteRequest', apiRouteRequest)
            const localVarPath = `/v1/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRouteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonStakeTransaction: async (apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTonStakingTransactionRequest' is not null or undefined
            assertParamExists('buildTonStakeTransaction', 'apiTonStakingTransactionRequest', apiTonStakingTransactionRequest)
            const localVarPath = `/v2/stake/ton/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTonStakingTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonUnstakeTransaction: async (apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTonStakingTransactionRequest' is not null or undefined
            assertParamExists('buildTonUnstakeTransaction', 'apiTonStakingTransactionRequest', apiTonStakingTransactionRequest)
            const localVarPath = `/v2/unstake/ton/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTonStakingTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2: async (apiTransactionsRequest: ApiTransactionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTransactionsRequest' is not null or undefined
            assertParamExists('buildTransactionsV2', 'apiTransactionsRequest', apiTransactionsRequest)
            const localVarPath = `/v2/route/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsResult: async (queryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('getTransactionsResult', 'queryId', queryId)
            const localVarPath = `/v1/route/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (queryId !== undefined) {
                localVarQueryParameter['query_id'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutingApi - functional programming interface
 * @export
 */
export const RoutingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoutingApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildRoute(apiRouteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTonStakeTransaction(apiTonStakingTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTonStakeTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTonUnstakeTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTransactionsV2(apiTransactionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTransactionsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTransactionResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsResult(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.getTransactionsResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoutingApi - factory interface
 * @export
 */
export const RoutingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutingApiFp(configuration)
    return {
        /**
         * Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute(apiRouteRequest: ApiRouteRequest, options?: any): AxiosPromise<ApiRoute> {
            return localVarFp.buildRoute(apiRouteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: any): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.buildTonStakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: any): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: any): AxiosPromise<ApiTransactionsResponse> {
            return localVarFp.buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsResult(queryId: number, options?: any): AxiosPromise<Array<ApiTransactionResult>> {
            return localVarFp.getTransactionsResult(queryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutingApi - object-oriented interface
 * @export
 * @class RoutingApi
 * @extends {BaseAPI}
 */
export class RoutingApi extends BaseAPI {
    /**
     * Returns the best route for the given trade pair
     * @param {ApiRouteRequest} apiRouteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildRoute(apiRouteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
     * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTonStakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
     * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
     * @param {ApiTransactionsRequest} apiTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get route transactions execution result
     * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).getTransactionsResult(queryId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TonApi - axios parameter creator
 * @export
 */
export const TonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletBalance', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/balance`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletVersion', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/version`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TonApi - functional programming interface
 * @export
 */
export const TonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TonApiAxiosParamCreator(configuration)
    return {
        /**
         * Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletBalance(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletVersion(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWalletVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletVersion(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TonApi - factory interface
 * @export
 */
export const TonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TonApiFp(configuration)
    return {
        /**
         * Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance(address: string, options?: any): AxiosPromise<string> {
            return localVarFp.getWalletBalance(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion(address: string, options?: any): AxiosPromise<GetWalletVersion200Response> {
            return localVarFp.getWalletVersion(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TonApi - object-oriented interface
 * @export
 * @class TonApi
 * @extends {BaseAPI}
 */
export class TonApi extends BaseAPI {
    /**
     * Get wallet balance in nanotons (1e-9 TON)
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletBalance(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletBalance(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns wallet version and revision
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletVersion(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletVersion(address, options).then((request) => request(this.axios, this.basePath));
    }
}



