/* tslint:disable */
/* eslint-disable */
/**
 * Swap Coffee API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAmmType = {
    Volatile: 'volatile',
    Stable: 'stable'
} as const;

export type ApiAmmType = typeof ApiAmmType[keyof typeof ApiAmmType];


/**
 * 
 * @export
 * @interface ApiAuthToken
 */
export interface ApiAuthToken {
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthToken
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiAuthToken
     */
    'administrative': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthToken
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiAuthToken
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiAuthTokenOption = {
    AllowCycles: 'allow_cycles'
} as const;

export type ApiAuthTokenOption = typeof ApiAuthTokenOption[keyof typeof ApiAuthTokenOption];


/**
 * 
 * @export
 * @interface ApiBlockchain
 */
export interface ApiBlockchain {
    /**
     * 
     * @type {string}
     * @memberof ApiBlockchain
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiCashbackCondition
 */
export interface ApiCashbackCondition {
    /**
     * 
     * @type {ApiCashbackConditionType}
     * @memberof ApiCashbackCondition
     */
    'type': ApiCashbackConditionType;
    /**
     * Arguments required to construct condition type
     * @type {Array<string>}
     * @memberof ApiCashbackCondition
     */
    'args'?: Array<string>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiCashbackConditionType = {
    None: 'none',
    Listed: 'listed',
    PartnerAddress: 'partner_address',
    Tokens: 'tokens',
    TokensPair: 'tokens-pair',
    TokensExact: 'tokens-exact',
    UsersWhitelist: 'users-whitelist',
    SwapTxMinAmount: 'swap-tx-min-amount'
} as const;

export type ApiCashbackConditionType = typeof ApiCashbackConditionType[keyof typeof ApiCashbackConditionType];


/**
 * 
 * @export
 * @interface ApiCashbackCreateRequest
 */
export interface ApiCashbackCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'description': string;
    /**
     * Where rewards stored
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'distributor': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'reward_token': string;
    /**
     * 
     * @type {Array<ApiCashbackCondition>}
     * @memberof ApiCashbackCreateRequest
     */
    'conditions': Array<ApiCashbackCondition>;
    /**
     * How many tokens will be distributed to users
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'distribute': number;
    /**
     * How many tokens already distributed to users
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'distributed': number;
    /**
     * Begin cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'start_time_seconds': number;
    /**
     * End cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'end_time_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackCreateRequest
     */
    'reward_denominator': number;
    /**
     * 
     * @type {Array<ApiCashbackLimitCreateRequest>}
     * @memberof ApiCashbackCreateRequest
     */
    'limits': Array<ApiCashbackLimitCreateRequest>;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackCreateRequest
     */
    'image_url': string;
    /**
     * 
     * @type {Array<ApiCashbackReference>}
     * @memberof ApiCashbackCreateRequest
     */
    'references': Array<ApiCashbackReference>;
}
/**
 * 
 * @export
 * @interface ApiCashbackInfo
 */
export interface ApiCashbackInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'description': string;
    /**
     * Where rewards stored
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'distributor': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'reward_token': string;
    /**
     * 
     * @type {Array<ApiCashbackCondition>}
     * @memberof ApiCashbackInfo
     */
    'conditions': Array<ApiCashbackCondition>;
    /**
     * How many tokens will be distributed to users
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'distribute': number;
    /**
     * How many tokens already distributed to users
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'distributed': number;
    /**
     * Begin cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'start_time_seconds': number;
    /**
     * End cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'end_time_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackInfo
     */
    'reward_denominator': number;
    /**
     * Can this cashback program accrue tokens to participants
     * @type {boolean}
     * @memberof ApiCashbackInfo
     */
    'is_active': boolean;
    /**
     * 
     * @type {Array<ApiCashbackLimit>}
     * @memberof ApiCashbackInfo
     */
    'limits': Array<ApiCashbackLimit>;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackInfo
     */
    'image_url': string;
    /**
     * 
     * @type {Array<ApiCashbackReference>}
     * @memberof ApiCashbackInfo
     */
    'references': Array<ApiCashbackReference>;
}
/**
 * 
 * @export
 * @interface ApiCashbackInfoResponse
 */
export interface ApiCashbackInfoResponse {
    /**
     * Total amount of similar cashback promos
     * @type {number}
     * @memberof ApiCashbackInfoResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<ApiCashbackInfo>}
     * @memberof ApiCashbackInfoResponse
     */
    'infos': Array<ApiCashbackInfo>;
}
/**
 * 
 * @export
 * @interface ApiCashbackLimit
 */
export interface ApiCashbackLimit {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimit
     */
    'limit_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimit
     */
    'interval_duration_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimit
     */
    'max_distribute_at_interval': number;
}
/**
 * 
 * @export
 * @interface ApiCashbackLimitCreateRequest
 */
export interface ApiCashbackLimitCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitCreateRequest
     */
    'interval_duration_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitCreateRequest
     */
    'max_distribute_at_interval': number;
}
/**
 * 
 * @export
 * @interface ApiCashbackLimitUpdateRequest
 */
export interface ApiCashbackLimitUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitUpdateRequest
     */
    'limit_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitUpdateRequest
     */
    'interval_duration_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackLimitUpdateRequest
     */
    'max_distribute_at_interval'?: number;
}
/**
 * 
 * @export
 * @interface ApiCashbackReference
 */
export interface ApiCashbackReference {
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackReference
     */
    'ref_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackReference
     */
    'ref_url': string;
}
/**
 * 
 * @export
 * @interface ApiCashbackUpdateRequest
 */
export interface ApiCashbackUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'description'?: string;
    /**
     * Where rewards stored
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'distributor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'reward_token'?: string;
    /**
     * 
     * @type {Array<ApiCashbackCondition>}
     * @memberof ApiCashbackUpdateRequest
     */
    'conditions'?: Array<ApiCashbackCondition>;
    /**
     * How many tokens will be distributed to users
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'distribute'?: number;
    /**
     * How many tokens already distributed to users
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'distributed'?: number;
    /**
     * Begin cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'start_time_seconds'?: number;
    /**
     * End cashback promo in unix seconds
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'end_time_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiCashbackUpdateRequest
     */
    'reward_denominator'?: number;
    /**
     * 
     * @type {Array<ApiCashbackLimitUpdateRequest>}
     * @memberof ApiCashbackUpdateRequest
     */
    'limits'?: Array<ApiCashbackLimitUpdateRequest>;
    /**
     * 
     * @type {string}
     * @memberof ApiCashbackUpdateRequest
     */
    'image_url'?: string;
    /**
     * 
     * @type {Array<ApiCashbackReference>}
     * @memberof ApiCashbackUpdateRequest
     */
    'references'?: Array<ApiCashbackReference>;
}
/**
 * 
 * @export
 * @interface ApiClaimState
 */
export interface ApiClaimState {
    /**
     * 
     * @type {ApiClaimingType}
     * @memberof ApiClaimState
     */
    'type': ApiClaimingType;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimState
     */
    'query_id': number;
    /**
     * When transaction happened in blockchain - unix seconds
     * @type {number}
     * @memberof ApiClaimState
     */
    'unix_time': number;
    /**
     * When transaction happened in blockchain - on-chain logical time
     * @type {number}
     * @memberof ApiClaimState
     */
    'logical_time': number;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimState
     */
    'transaction_hash': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimState
     */
    'token_address': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimState
     */
    'wallet_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimState
     */
    'amount': number;
    /**
     * 
     * @type {ApiWithdrawal}
     * @memberof ApiClaimState
     */
    'withdrawal': ApiWithdrawal;
}


/**
 * 
 * @export
 * @interface ApiClaimStateResponse
 */
export interface ApiClaimStateResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiClaimStateResponse
     */
    'total_count': number;
    /**
     * 
     * @type {Array<ApiClaimState>}
     * @memberof ApiClaimStateResponse
     */
    'items': Array<ApiClaimState>;
}
/**
 * 
 * @export
 * @interface ApiClaimingStats
 */
export interface ApiClaimingStats {
    /**
     * 
     * @type {Array<ApiClaimingTypeStats>}
     * @memberof ApiClaimingStats
     */
    'aggregated': Array<ApiClaimingTypeStats>;
    /**
     * 
     * @type {Array<ApiClaimingTokenStats>}
     * @memberof ApiClaimingStats
     */
    'detailed': Array<ApiClaimingTokenStats>;
}
/**
 * 
 * @export
 * @interface ApiClaimingTokenStats
 */
export interface ApiClaimingTokenStats {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiClaimingTokenStats
     */
    'token': ApiToken;
    /**
     * Wallet\'s address where token resides
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'wallet': string;
    /**
     * 
     * @type {ApiClaimingType}
     * @memberof ApiClaimingTokenStats
     */
    'type': ApiClaimingType;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'claimed': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'locked': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClaimingTokenStats
     */
    'available': string;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimingTokenStats
     */
    'available_usd': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiClaimingType = {
    All: 'all',
    Referral: 'referral',
    Cashback: 'cashback'
} as const;

export type ApiClaimingType = typeof ApiClaimingType[keyof typeof ApiClaimingType];


/**
 * 
 * @export
 * @interface ApiClaimingTypeStats
 */
export interface ApiClaimingTypeStats {
    /**
     * 
     * @type {ApiClaimingType}
     * @memberof ApiClaimingTypeStats
     */
    'type': ApiClaimingType;
    /**
     * 
     * @type {number}
     * @memberof ApiClaimingTypeStats
     */
    'available_usd': number;
}


/**
 * 
 * @export
 * @interface ApiContestInformation
 */
export interface ApiContestInformation {
    /**
     * 
     * @type {string}
     * @memberof ApiContestInformation
     */
    'description': string;
    /**
     * in seconds
     * @type {number}
     * @memberof ApiContestInformation
     */
    'start_time_unix': number;
    /**
     * in seconds
     * @type {number}
     * @memberof ApiContestInformation
     */
    'end_time_unix': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiContestInformation
     */
    'tokens': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiContestInformationResponse
 */
export interface ApiContestInformationResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiContestInformationResponse
     */
    'id': number;
    /**
     * 
     * @type {ApiContestInformation}
     * @memberof ApiContestInformationResponse
     */
    'info': ApiContestInformation;
}
/**
 * 
 * @export
 * @interface ApiContestTokenStats
 */
export interface ApiContestTokenStats {
    /**
     * token master-contract address
     * @type {string}
     * @memberof ApiContestTokenStats
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiContestTokenStats
     */
    'volume_raw': string;
    /**
     * 
     * @type {number}
     * @memberof ApiContestTokenStats
     */
    'volume_usd': number;
}
/**
 * 
 * @export
 * @interface ApiContestUserStats
 */
export interface ApiContestUserStats {
    /**
     * 
     * @type {string}
     * @memberof ApiContestUserStats
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiContestUserStats
     */
    'position': number;
    /**
     * 
     * @type {Array<ApiContestTokenStats>}
     * @memberof ApiContestUserStats
     */
    'tokens': Array<ApiContestTokenStats>;
}
/**
 * 
 * @export
 * @interface ApiCreateAuthTokenRequest
 */
export interface ApiCreateAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiCreateAuthTokenRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiCreateAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiCreateAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiDex
 */
export interface ApiDex {
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiDex
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiEditAuthTokenRequest
 */
export interface ApiEditAuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiEditAuthTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiEditAuthTokenRequest
     */
    'hourly_limit'?: number;
    /**
     * 
     * @type {Array<ApiAuthTokenOption>}
     * @memberof ApiEditAuthTokenRequest
     */
    'options'?: Array<ApiAuthTokenOption>;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface ApiHistoricalTransaction
 */
export interface ApiHistoricalTransaction {
    /**
     * 
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'route_id': number;
    /**
     * When transaction happened in blockchain - unix seconds
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'unix_time': number;
    /**
     * When transaction happened in blockchain - on-chain logical time
     * @type {number}
     * @memberof ApiHistoricalTransaction
     */
    'logical_time': number;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiHistoricalTransaction
     */
    'from': ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiHistoricalTransaction
     */
    'to': ApiQuantifiedToken;
    /**
     * 
     * @type {string}
     * @memberof ApiHistoricalTransaction
     */
    'dex': string;
}
/**
 * 
 * @export
 * @interface ApiPool
 */
export interface ApiPool {
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiPool
     */
    'address': string;
    /**
     * 
     * @type {ApiPoolType}
     * @memberof ApiPool
     */
    'type': ApiPoolType;
    /**
     * 
     * @type {ApiAmmType}
     * @memberof ApiPool
     */
    'amm_type': ApiAmmType;
    /**
     * 
     * @type {Array<ApiToken>}
     * @memberof ApiPool
     */
    'tokens': Array<ApiToken>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiPool
     */
    'extra_decimals'?: Array<number>;
    /**
     * 
     * @type {Array<ApiTokenRestrictions>}
     * @memberof ApiPool
     */
    'restrictions'?: Array<ApiTokenRestrictions>;
    /**
     * 
     * @type {ApiPoolFees}
     * @memberof ApiPool
     */
    'fees': ApiPoolFees;
}


/**
 * 
 * @export
 * @interface ApiPoolFees
 */
export interface ApiPoolFees {
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'average_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'divider'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'input'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'output'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'first_token'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiPoolFees
     */
    'second_token'?: number;
}
/**
 * Configures the DEX pools that can appear in the generated route. By setting blockchains = [\"ton\"] inside it, you can remove the dexes field; max_volatility allows you to exclude pools whose volatility has been above a certain percentage in the last 15 minutes. This makes sense when you allow 2-3 intermediate tokens or a large number of splits to smooth out potential issues.
 * @export
 * @interface ApiPoolSelector
 */
export interface ApiPoolSelector {
    /**
     * If specified, only pools from given blockchains will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'blockchains'?: Array<string>;
    /**
     * If specified, only pools from given dexes will be used for routing
     * @type {Array<string>}
     * @memberof ApiPoolSelector
     */
    'dexes'?: Array<string>;
    /**
     * If specified, only pools with volatility lower than given value will be used for routing
     * @type {number}
     * @memberof ApiPoolSelector
     */
    'max_volatility'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiPoolType = {
    Public: 'public',
    Private: 'private',
    Slumbering: 'slumbering',
    Invalid: 'invalid'
} as const;

export type ApiPoolType = typeof ApiPoolType[keyof typeof ApiPoolType];


/**
 * 
 * @export
 * @interface ApiProofValidationRequest
 */
export interface ApiProofValidationRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiProofValidationRequest
     */
    'public_key': string;
    /**
     * Base64-encoded initial state. Must be retrieved from ton-connect.
     * @type {string}
     * @memberof ApiProofValidationRequest
     */
    'wallet_state_init': string;
    /**
     * 
     * @type {ApiTonProof}
     * @memberof ApiProofValidationRequest
     */
    'proof': ApiTonProof;
}
/**
 * 
 * @export
 * @interface ApiQuantifiedToken
 */
export interface ApiQuantifiedToken {
    /**
     * 
     * @type {string}
     * @memberof ApiQuantifiedToken
     */
    'token_blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiQuantifiedToken
     */
    'token_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiQuantifiedToken
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiRawTransactionRecord
 */
export interface ApiRawTransactionRecord {
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'query_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'route_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'hash': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'lt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'user_wallet': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'token_from': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'token_to': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_from': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_from_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_to': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'amount_to_usd': number;
    /**
     * 
     * @type {string}
     * @memberof ApiRawTransactionRecord
     */
    'dex': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRawTransactionRecord
     */
    'ref_fee_usd': number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRawTransactionRecord
     */
    'failed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRawTransactionRecord
     */
    'suspicious': boolean;
}
/**
 * 
 * @export
 * @interface ApiRecommendedGas
 */
export interface ApiRecommendedGas {
    /**
     * 
     * @type {string}
     * @memberof ApiRecommendedGas
     */
    'blockchain': string;
    /**
     * 
     * @type {number}
     * @memberof ApiRecommendedGas
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountInfo
 */
export interface ApiReferralAccountInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiReferralAccountInfo
     */
    'link': string;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'level': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'fees_percentage': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'referrals_count': number;
    /**
     * Number of transactions sent by referral users
     * @type {number}
     * @memberof ApiReferralAccountInfo
     */
    'transactions_count': number;
    /**
     * 
     * @type {ApiReferralAccountRewards}
     * @memberof ApiReferralAccountInfo
     */
    'rewards': ApiReferralAccountRewards;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountInfoUpdate
 */
export interface ApiReferralAccountInfoUpdate {
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountInfoUpdate
     */
    'fees_percentage': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountReward
 */
export interface ApiReferralAccountReward {
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountReward
     */
    'volume': number;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralAccountReward
     */
    'fees': number;
}
/**
 * 
 * @export
 * @interface ApiReferralAccountRewards
 */
export interface ApiReferralAccountRewards {
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralAccountRewards
     */
    'monthly': ApiReferralAccountReward;
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralAccountRewards
     */
    'total': ApiReferralAccountReward;
}
/**
 * 
 * @export
 * @interface ApiReferralInfo
 */
export interface ApiReferralInfo {
    /**
     * 
     * @type {string}
     * @memberof ApiReferralInfo
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiReferralInfo
     */
    'transactions_count': number;
    /**
     * 
     * @type {ApiReferralAccountReward}
     * @memberof ApiReferralInfo
     */
    'rewards': ApiReferralAccountReward;
}
/**
 * 
 * @export
 * @interface ApiRoute
 */
export interface ApiRoute {
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoute
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'input_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'output_usd': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'savings'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'left_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'recommended_gas': number;
    /**
     * 
     * @type {number}
     * @memberof ApiRoute
     */
    'price_impact': number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoute
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiRouteRequest
 */
export interface ApiRouteRequest {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'input_token': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiRouteRequest
     */
    'output_token': ApiTokenAddress;
    /**
     * Input amount in tokens (not nano!) to be swapped
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'input_amount'?: number;
    /**
     * If specified, the route will be built to get the specified output amount. If not specified, the route will be built to get the maximum output amount for the given input amount.
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'output_amount'?: number;
    /**
     * Defines the maximum number of independent paths (i.e., transactions) the route can split into. For v4 wallets, you can omit this or set it to 4; for v5 wallets, you can set it to 20 (this is our internal upper limit, and we may reduce it to 10).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_splits'?: number;
    /**
     * Defines the maximum length of each path in tokens. It accepts values from [2; 5]. If it\'s 2, only direct swaps A -> B without multihops are possible. If it\'s 3, there can be a maximum of 1 intermediate token, i.e., A -> X -> B. If it\'s 4/5, there can be 2/3 intermediate tokens. A value of 2 deprives you of more profitable exchanges by finding market inefficiencies and does not allow you to exchange tokens without a direct pair (since there can be no intermediate tokens). The higher the value, the more profitable routes can be built, but the higher the likelihood that the user ends up with an intermediate token (since our blockchain is asynchronous, and some swap in the middle of the route may fail due to slippage).
     * @type {number}
     * @memberof ApiRouteRequest
     */
    'max_length'?: number;
    /**
     * 
     * @type {ApiPoolSelector}
     * @memberof ApiRouteRequest
     */
    'pool_selector'?: ApiPoolSelector;
}
/**
 * 
 * @export
 * @interface ApiRoutingStep
 */
export interface ApiRoutingStep {
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'dex': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRoutingStep
     */
    'pool_address': string;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'input_token': ApiToken;
    /**
     * 
     * @type {ApiToken}
     * @memberof ApiRoutingStep
     */
    'output_token': ApiToken;
    /**
     * 
     * @type {ApiSwap}
     * @memberof ApiRoutingStep
     */
    'swap': ApiSwap;
    /**
     * 
     * @type {number}
     * @memberof ApiRoutingStep
     */
    'recommended_gas': number;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiRoutingStep
     */
    'next'?: Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiSwap
 */
export interface ApiSwap {
    /**
     * 
     * @type {ApiSwapResult}
     * @memberof ApiSwap
     */
    'result': ApiSwapResult;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'input_amount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'output_amount': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'before_reserves': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiSwap
     */
    'after_reserves': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ApiSwap
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiSwap
     */
    'left_amount'?: number;
}


/**
 * Result of the swap
 * @export
 * @enum {string}
 */

export const ApiSwapResult = {
    FullyFulfilled: 'fully_fulfilled',
    PartiallyFulfilled: 'partially_fulfilled',
    Unavailable: 'unavailable'
} as const;

export type ApiSwapResult = typeof ApiSwapResult[keyof typeof ApiSwapResult];


/**
 * 
 * @export
 * @interface ApiSwapTransaction
 */
export interface ApiSwapTransaction {
    /**
     * 
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'address': string;
    /**
     * Amount of nanotons to be sent. Can be passed to TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'value': string;
    /**
     * Base64-encoded cell. Treated as a payload field in TonConnect transaction.
     * @type {string}
     * @memberof ApiSwapTransaction
     */
    'cell': string;
    /**
     * Internal message send mode. More: https://docs.ton.org/develop/smart-contracts/messages#message-modes
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'send_mode': number;
    /**
     * Unique identifier of the query used for tracking swap.coffee transactions among others
     * @type {number}
     * @memberof ApiSwapTransaction
     */
    'query_id': number;
}
/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * 
     * @type {ApiTokenAddress}
     * @memberof ApiToken
     */
    'address': ApiTokenAddress;
    /**
     * 
     * @type {ApiTokenMetadata}
     * @memberof ApiToken
     */
    'metadata': ApiTokenMetadata;
}
/**
 * 
 * @export
 * @interface ApiTokenAddress
 */
export interface ApiTokenAddress {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'blockchain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenAddress
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface ApiTokenClaimRequest
 */
export interface ApiTokenClaimRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenClaimRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenClaimRequest
     */
    'token_address': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenClaimRequest
     */
    'wallet_address'?: string;
}
/**
 * 
 * @export
 * @interface ApiTokenClaimResponse
 */
export interface ApiTokenClaimResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenClaimResponse
     */
    'query_id': number;
    /**
     * 
     * @type {ApiTransactionBoc}
     * @memberof ApiTokenClaimResponse
     */
    'message': ApiTransactionBoc;
}
/**
 * 
 * @export
 * @interface ApiTokenMetadata
 */
export interface ApiTokenMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenMetadata
     */
    'decimals': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenMetadata
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiTokenMetadata
     */
    'listed': boolean;
}
/**
 * 
 * @export
 * @interface ApiTokenRestrictions
 */
export interface ApiTokenRestrictions {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'min_swap_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestrictions
     */
    'max_swap_amount'?: number;
}
/**
 * 
 * @export
 * @interface ApiTonProof
 */
export interface ApiTonProof {
    /**
     * Valid till, in seconds
     * @type {number}
     * @memberof ApiTonProof
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof ApiTonProof
     */
    'domain_len': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'domain_val': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'payload': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonProof
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface ApiTonStakingTransactionRequest
 */
export interface ApiTonStakingTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'referral_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'sender_address': string;
    /**
     * 
     * @type {number}
     * @memberof ApiTonStakingTransactionRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTonStakingTransactionRequest
     */
    'token_address': string;
}
/**
 * 
 * @export
 * @interface ApiTransactionBoc
 */
export interface ApiTransactionBoc {
    /**
     * Base64-encoded cell. Treated as a payload field in TonConnect transaction.
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'payload_cell': string;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'address': string;
    /**
     * Amount of nanotons to be sent. Can be passed to TonConnect transaction.
     * @type {string}
     * @memberof ApiTransactionBoc
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ApiTransactionResult
 */
export interface ApiTransactionResult {
    /**
     * 
     * @type {ApiTransactionStatus}
     * @memberof ApiTransactionResult
     */
    'status': ApiTransactionStatus;
    /**
     * 
     * @type {Array<ApiTransactionStepResult>}
     * @memberof ApiTransactionResult
     */
    'steps': Array<ApiTransactionStepResult>;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionResult
     */
    'input'?: ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionResult
     */
    'output'?: ApiQuantifiedToken;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStatus = {
    Pending: 'pending',
    PartiallyComplete: 'partially_complete',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStatus = typeof ApiTransactionStatus[keyof typeof ApiTransactionStatus];


/**
 * 
 * @export
 * @interface ApiTransactionStepResult
 */
export interface ApiTransactionStepResult {
    /**
     * 
     * @type {ApiTransactionStepStatus}
     * @memberof ApiTransactionStepResult
     */
    'status': ApiTransactionStepStatus;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionStepResult
     */
    'input'?: ApiQuantifiedToken;
    /**
     * 
     * @type {ApiQuantifiedToken}
     * @memberof ApiTransactionStepResult
     */
    'output'?: ApiQuantifiedToken;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiTransactionStepStatus = {
    Pending: 'pending',
    Cancelled: 'cancelled',
    Succeeded: 'succeeded',
    Failed: 'failed',
    TimedOut: 'timed_out'
} as const;

export type ApiTransactionStepStatus = typeof ApiTransactionStepStatus[keyof typeof ApiTransactionStepStatus];


/**
 * 
 * @export
 * @interface ApiTransactionsRequest
 */
export interface ApiTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'sender_address': string;
    /**
     * Slippage in fractions (1 = 100%, 0 = 0%). If the slippage is exceeded, the transaction will not be executed and intermediate tokens will be returned to the sender.
     * @type {number}
     * @memberof ApiTransactionsRequest
     */
    'slippage': number;
    /**
     * 
     * @type {string}
     * @memberof ApiTransactionsRequest
     */
    'referral_name'?: string;
    /**
     * 
     * @type {Array<ApiRoutingStep>}
     * @memberof ApiTransactionsRequest
     */
    'paths': Array<ApiRoutingStep>;
}
/**
 * 
 * @export
 * @interface ApiTransactionsResponse
 */
export interface ApiTransactionsResponse {
    /**
     * Unique identifier of the route used for tracking.
     * @type {number}
     * @memberof ApiTransactionsResponse
     */
    'route_id': number;
    /**
     * 
     * @type {Array<ApiSwapTransaction>}
     * @memberof ApiTransactionsResponse
     */
    'transactions': Array<ApiSwapTransaction>;
}
/**
 * 
 * @export
 * @interface ApiUserCashbackInfo
 */
export interface ApiUserCashbackInfo {
    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfo
     */
    'cashback_id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfo
     */
    'earned_usd': number;
}
/**
 * 
 * @export
 * @interface ApiUserCashbackInfoTotal
 */
export interface ApiUserCashbackInfoTotal {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfoTotal
     */
    'cashback_count': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserCashbackInfoTotal
     */
    'total_earned_usd': number;
}
/**
 * 
 * @export
 * @interface ApiWithdrawal
 */
export interface ApiWithdrawal {
    /**
     * 
     * @type {ApiWithdrawalType}
     * @memberof ApiWithdrawal
     */
    'type': ApiWithdrawalType;
    /**
     * 
     * @type {ApiWithdrawalStatus}
     * @memberof ApiWithdrawal
     */
    'status': ApiWithdrawalStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiWithdrawalStatus = {
    Unhandled: 'unhandled',
    Processing: 'processing',
    Processed: 'processed'
} as const;

export type ApiWithdrawalStatus = typeof ApiWithdrawalStatus[keyof typeof ApiWithdrawalStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiWithdrawalType = {
    Repay: 'repay',
    Refund: 'refund'
} as const;

export type ApiWithdrawalType = typeof ApiWithdrawalType[keyof typeof ApiWithdrawalType];


/**
 * 
 * @export
 * @interface GetBlockchainsDefaultResponse
 */
export interface GetBlockchainsDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof GetBlockchainsDefaultResponse
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface GetWalletVersion200Response
 */
export interface GetWalletVersion200Response {
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'version': number;
    /**
     * 
     * @type {number}
     * @memberof GetWalletVersion200Response
     */
    'revision': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCreateAuthTokenRequest' is not null or undefined
            assertParamExists('createAuthToken', 'apiCreateAuthTokenRequest', apiCreateAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCreateAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteAuthToken', 'key', key)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken: async (apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiEditAuthTokenRequest' is not null or undefined
            assertParamExists('editAuthToken', 'apiEditAuthTokenRequest', apiEditAuthTokenRequest)
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiEditAuthTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(apiCreateAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.createAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthToken(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthToken(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editAuthToken(apiEditAuthTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.editAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiAuthToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getAuthTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new auth token
         * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: any): AxiosPromise<ApiAuthToken> {
            return localVarFp.createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete existing auth token
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthToken(key: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAuthToken(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit existing auth token
         * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: any): AxiosPromise<ApiAuthToken> {
            return localVarFp.editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing auth tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthTokens(options?: any): AxiosPromise<Array<ApiAuthToken>> {
            return localVarFp.getAuthTokens(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Create new auth token
     * @param {ApiCreateAuthTokenRequest} apiCreateAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAuthToken(apiCreateAuthTokenRequest: ApiCreateAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).createAuthToken(apiCreateAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete existing auth token
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteAuthToken(key: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteAuthToken(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit existing auth token
     * @param {ApiEditAuthTokenRequest} apiEditAuthTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public editAuthToken(apiEditAuthTokenRequest: ApiEditAuthTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).editAuthToken(apiEditAuthTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing auth tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthTokens(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CashbackApi - axios parameter creator
 * @export
 */
export const CashbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new cashback distribution. For internal usage only
         * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashback: async (apiCashbackCreateRequest: ApiCashbackCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCashbackCreateRequest' is not null or undefined
            assertParamExists('createCashback', 'apiCashbackCreateRequest', apiCashbackCreateRequest)
            const localVarPath = `/v1/cashback/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCashbackCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashback info
         * @param {number} id Cashback id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfo: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCashbackInfo', 'id', id)
            const localVarPath = `/v1/cashback/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashbacks info
         * @param {string} [distributor] Address, from which, token will be distributed to participants
         * @param {string} [token] Cashback token
         * @param {boolean} [active] Filter out active promotions only
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfos: async (distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cashback/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (distributor !== undefined) {
                localVarQueryParameter['distributor'] = distributor;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashback promos rewards for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfo: async (address: string, xVerify: string, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getUserCashbackInfo', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getUserCashbackInfo', 'xVerify', xVerify)
            const localVarPath = `/v1/cashback/user/{address}/list`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cashback total info for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfoTotal: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getUserCashbackInfoTotal', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getUserCashbackInfoTotal', 'xVerify', xVerify)
            const localVarPath = `/v1/cashback/user/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update cashback information. For internal usage only
         * @param {number} id Cashback id
         * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCashback: async (id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCashback', 'id', id)
            // verify required parameter 'apiCashbackUpdateRequest' is not null or undefined
            assertParamExists('updateCashback', 'apiCashbackUpdateRequest', apiCashbackUpdateRequest)
            const localVarPath = `/v1/cashback/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCashbackUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashbackApi - functional programming interface
 * @export
 */
export const CashbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new cashback distribution. For internal usage only
         * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCashback(apiCashbackCreateRequest: ApiCashbackCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCashback(apiCashbackCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.createCashback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashback info
         * @param {number} id Cashback id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashbackInfo(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashbackInfo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getCashbackInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashbacks info
         * @param {string} [distributor] Address, from which, token will be distributed to participants
         * @param {string} [token] Cashback token
         * @param {boolean} [active] Filter out active promotions only
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashbackInfos(distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashbackInfos(distributor, token, active, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getCashbackInfos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashback promos rewards for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCashbackInfo(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUserCashbackInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCashbackInfo(address, xVerify, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getUserCashbackInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cashback total info for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCashbackInfoTotal(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserCashbackInfoTotal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCashbackInfoTotal(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.getUserCashbackInfoTotal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update cashback information. For internal usage only
         * @param {number} id Cashback id
         * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCashback(id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCashbackInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCashback(id, apiCashbackUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashbackApi.updateCashback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CashbackApi - factory interface
 * @export
 */
export const CashbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashbackApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new cashback distribution. For internal usage only
         * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashback(apiCashbackCreateRequest: ApiCashbackCreateRequest, options?: any): AxiosPromise<ApiCashbackInfo> {
            return localVarFp.createCashback(apiCashbackCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashback info
         * @param {number} id Cashback id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfo(id: number, options?: any): AxiosPromise<ApiCashbackInfo> {
            return localVarFp.getCashbackInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashbacks info
         * @param {string} [distributor] Address, from which, token will be distributed to participants
         * @param {string} [token] Cashback token
         * @param {boolean} [active] Filter out active promotions only
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashbackInfos(distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options?: any): AxiosPromise<ApiCashbackInfoResponse> {
            return localVarFp.getCashbackInfos(distributor, token, active, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashback promos rewards for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfo(address: string, xVerify: string, size?: number, page?: number, options?: any): AxiosPromise<Array<ApiUserCashbackInfo>> {
            return localVarFp.getUserCashbackInfo(address, xVerify, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cashback total info for user
         * @param {string} address User address
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCashbackInfoTotal(address: string, xVerify: string, options?: any): AxiosPromise<ApiUserCashbackInfoTotal> {
            return localVarFp.getUserCashbackInfoTotal(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update cashback information. For internal usage only
         * @param {number} id Cashback id
         * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCashback(id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options?: any): AxiosPromise<ApiCashbackInfo> {
            return localVarFp.updateCashback(id, apiCashbackUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CashbackApi - object-oriented interface
 * @export
 * @class CashbackApi
 * @extends {BaseAPI}
 */
export class CashbackApi extends BaseAPI {
    /**
     * 
     * @summary Create new cashback distribution. For internal usage only
     * @param {ApiCashbackCreateRequest} apiCashbackCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public createCashback(apiCashbackCreateRequest: ApiCashbackCreateRequest, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).createCashback(apiCashbackCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashback info
     * @param {number} id Cashback id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getCashbackInfo(id: number, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getCashbackInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashbacks info
     * @param {string} [distributor] Address, from which, token will be distributed to participants
     * @param {string} [token] Cashback token
     * @param {boolean} [active] Filter out active promotions only
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getCashbackInfos(distributor?: string, token?: string, active?: boolean, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getCashbackInfos(distributor, token, active, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashback promos rewards for user
     * @param {string} address User address
     * @param {string} xVerify TON proof for the given address
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getUserCashbackInfo(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getUserCashbackInfo(address, xVerify, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cashback total info for user
     * @param {string} address User address
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public getUserCashbackInfoTotal(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).getUserCashbackInfoTotal(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update cashback information. For internal usage only
     * @param {number} id Cashback id
     * @param {ApiCashbackUpdateRequest} apiCashbackUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashbackApi
     */
    public updateCashback(id: number, apiCashbackUpdateRequest: ApiCashbackUpdateRequest, options?: RawAxiosRequestConfig) {
        return CashbackApiFp(this.configuration).updateCashback(id, apiCashbackUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClaimApi - axios parameter creator
 * @export
 */
export const ClaimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimTokens: async (address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('claimTokens', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('claimTokens', 'xVerify', xVerify)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('claimTokens', 'type', type)
            // verify required parameter 'apiTokenClaimRequest' is not null or undefined
            assertParamExists('claimTokens', 'apiTokenClaimRequest', apiTokenClaimRequest)
            const localVarPath = `/v1/claim/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTokenClaimRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get state of account claimings
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountClaimingState: async (address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountClaimingState', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getAccountClaimingState', 'xVerify', xVerify)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getAccountClaimingState', 'type', type)
            const localVarPath = `/v1/claim/{address}/state`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s claiming stats
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingStats: async (address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getClaimingStats', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getClaimingStats', 'xVerify', xVerify)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getClaimingStats', 'type', type)
            const localVarPath = `/v1/claim/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get claiming transaction execution result
         * @param {Array<number>} queryId Public query ids to track withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingTransactionResult: async (queryId: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('getClaimingTransactionResult', 'queryId', queryId)
            const localVarPath = `/v1/claim/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (queryId) {
                localVarQueryParameter['query_id'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClaimApi - functional programming interface
 * @export
 */
export const ClaimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClaimApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimTokens(address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTokenClaimResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimTokens(address, xVerify, type, apiTokenClaimRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.claimTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get state of account claimings
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountClaimingState(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClaimStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountClaimingState(address, xVerify, type, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getAccountClaimingState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s claiming stats
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimingStats(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClaimingStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimingStats(address, xVerify, type, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getClaimingStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get claiming transaction execution result
         * @param {Array<number>} queryId Public query ids to track withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimingTransactionResult(queryId: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimingTransactionResult(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClaimApi.getClaimingTransactionResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClaimApi - factory interface
 * @export
 */
export const ClaimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClaimApiFp(configuration)
    return {
        /**
         * 
         * @summary Claim tokens
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimTokens(address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: any): AxiosPromise<Array<ApiTokenClaimResponse>> {
            return localVarFp.claimTokens(address, xVerify, type, apiTokenClaimRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get state of account claimings
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountClaimingState(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: any): AxiosPromise<ApiClaimStateResponse> {
            return localVarFp.getAccountClaimingState(address, xVerify, type, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s claiming stats
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {ApiClaimingType} type 
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingStats(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: any): AxiosPromise<ApiClaimingStats> {
            return localVarFp.getClaimingStats(address, xVerify, type, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get claiming transaction execution result
         * @param {Array<number>} queryId Public query ids to track withdraw request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimingTransactionResult(queryId: Array<number>, options?: any): AxiosPromise<ApiTransactionStatus> {
            return localVarFp.getClaimingTransactionResult(queryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClaimApi - object-oriented interface
 * @export
 * @class ClaimApi
 * @extends {BaseAPI}
 */
export class ClaimApi extends BaseAPI {
    /**
     * 
     * @summary Claim tokens
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiClaimingType} type 
     * @param {Array<ApiTokenClaimRequest>} apiTokenClaimRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public claimTokens(address: string, xVerify: string, type: ApiClaimingType, apiTokenClaimRequest: Array<ApiTokenClaimRequest>, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).claimTokens(address, xVerify, type, apiTokenClaimRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get state of account claimings
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiClaimingType} type 
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getAccountClaimingState(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getAccountClaimingState(address, xVerify, type, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s claiming stats
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {ApiClaimingType} type 
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getClaimingStats(address: string, xVerify: string, type: ApiClaimingType, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getClaimingStats(address, xVerify, type, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get claiming transaction execution result
     * @param {Array<number>} queryId Public query ids to track withdraw request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimApi
     */
    public getClaimingTransactionResult(queryId: Array<number>, options?: RawAxiosRequestConfig) {
        return ClaimApiFp(this.configuration).getClaimingTransactionResult(queryId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContestsApi - axios parameter creator
 * @export
 */
export const ContestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new contest. For internal usage only
         * @param {ApiContestInformation} apiContestInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContest: async (apiContestInformation: ApiContestInformation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiContestInformation' is not null or undefined
            assertParamExists('createContest', 'apiContestInformation', apiContestInformation)
            const localVarPath = `/v1/contests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiContestInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContest: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContest', 'id', id)
            const localVarPath = `/v1/contests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get top users\' stats for contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestTopUsersStats: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContestTopUsersStats', 'id', id)
            const localVarPath = `/v1/contests/{id}/top`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user stats for contest
         * @param {number} id 
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestUserStats: async (id: number, address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContestUserStats', 'id', id)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getContestUserStats', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getContestUserStats', 'xVerify', xVerify)
            const localVarPath = `/v1/contests/{id}/user/{address}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x_verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contests
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContests: async (active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContestsApi - functional programming interface
 * @export
 */
export const ContestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new contest. For internal usage only
         * @param {ApiContestInformation} apiContestInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContest(apiContestInformation: ApiContestInformation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiContestInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContest(apiContestInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.createContest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContest(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiContestInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContest(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get top users\' stats for contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContestTopUsersStats(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiContestUserStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContestTopUsersStats(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContestTopUsersStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user stats for contest
         * @param {number} id 
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContestUserStats(id: number, address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiContestUserStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContestUserStats(id, address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContestUserStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get contests
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContests(active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiContestInformationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContests(active, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestsApi.getContests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContestsApi - factory interface
 * @export
 */
export const ContestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContestsApiFp(configuration)
    return {
        /**
         * Create new contest. For internal usage only
         * @param {ApiContestInformation} apiContestInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContest(apiContestInformation: ApiContestInformation, options?: any): AxiosPromise<ApiContestInformationResponse> {
            return localVarFp.createContest(apiContestInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContest(id: number, options?: any): AxiosPromise<ApiContestInformationResponse> {
            return localVarFp.getContest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get top users\' stats for contest
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestTopUsersStats(id: number, options?: any): AxiosPromise<Array<ApiContestUserStats>> {
            return localVarFp.getContestTopUsersStats(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user stats for contest
         * @param {number} id 
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestUserStats(id: number, address: string, xVerify: string, options?: any): AxiosPromise<ApiContestUserStats> {
            return localVarFp.getContestUserStats(id, address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contests
         * @param {boolean} [active] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContests(active?: boolean, options?: any): AxiosPromise<Array<ApiContestInformationResponse>> {
            return localVarFp.getContests(active, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContestsApi - object-oriented interface
 * @export
 * @class ContestsApi
 * @extends {BaseAPI}
 */
export class ContestsApi extends BaseAPI {
    /**
     * Create new contest. For internal usage only
     * @param {ApiContestInformation} apiContestInformation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public createContest(apiContestInformation: ApiContestInformation, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).createContest(apiContestInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contest
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContest(id: number, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get top users\' stats for contest
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContestTopUsersStats(id: number, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContestTopUsersStats(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user stats for contest
     * @param {number} id 
     * @param {string} address 
     * @param {string} xVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContestUserStats(id: number, address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContestUserStats(id, address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contests
     * @param {boolean} [active] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getContests(active?: boolean, options?: RawAxiosRequestConfig) {
        return ContestsApiFp(this.configuration).getContests(active, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityApi - axios parameter creator
 * @export
 */
export const EntityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/blockchains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex: async (blockchain: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getDex', 'blockchain', blockchain)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDex', 'name', name)
            const localVarPath = `/v1/dex/{blockchain}/{name}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes: async (blockchain?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dexes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (blockchain !== undefined) {
                localVarQueryParameter['blockchain'] = blockchain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getPool', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPool', 'address', address)
            const localVarPath = `/v1/pool/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (blockchain: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getToken', 'blockchain', blockchain)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getToken', 'address', address)
            const localVarPath = `/v1/token/{blockchain}/{address}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (listed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (listed !== undefined) {
                localVarQueryParameter['listed'] = listed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol: async (blockchain: string, symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockchain' is not null or undefined
            assertParamExists('getTokensBySymbol', 'blockchain', blockchain)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTokensBySymbol', 'symbol', symbol)
            const localVarPath = `/v1/token/{blockchain}/by-symbol/{symbol}`
                .replace(`{${"blockchain"}}`, encodeURIComponent(String(blockchain)))
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityApi - functional programming interface
 * @export
 */
export const EntityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockchains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiBlockchain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockchains(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getBlockchains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDex>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDex(blockchain, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDexes(blockchain?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiDex>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDexes(blockchain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getDexes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(blockchain, address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(listed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(listed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokensBySymbol(blockchain, symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityApi.getTokensBySymbol']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntityApi - factory interface
 * @export
 */
export const EntityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityApiFp(configuration)
    return {
        /**
         * 
         * @summary Get supported blockchains. Currently only TON is supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockchains(options?: any): AxiosPromise<Array<ApiBlockchain>> {
            return localVarFp.getBlockchains(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given decentralized exchange for the given blockchain
         * @param {string} blockchain 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDex(blockchain: string, name: string, options?: any): AxiosPromise<ApiDex> {
            return localVarFp.getDex(blockchain, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
         * @param {string} [blockchain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDexes(blockchain?: string, options?: any): AxiosPromise<Array<ApiDex>> {
            return localVarFp.getDexes(blockchain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given liquidity pool for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(blockchain: string, address: string, options?: any): AxiosPromise<ApiPool> {
            return localVarFp.getPool(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given token for the given blockchain
         * @param {string} blockchain 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(blockchain: string, address: string, options?: any): AxiosPromise<ApiToken> {
            return localVarFp.getToken(blockchain, address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of tokens supported by the service
         * @param {boolean} [listed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(listed?: boolean, options?: any): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokens(listed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the given token by its symbol for the given blockchain
         * @param {string} blockchain 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokensBySymbol(blockchain: string, symbol: string, options?: any): AxiosPromise<Array<ApiToken>> {
            return localVarFp.getTokensBySymbol(blockchain, symbol, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityApi - object-oriented interface
 * @export
 * @class EntityApi
 * @extends {BaseAPI}
 */
export class EntityApi extends BaseAPI {
    /**
     * 
     * @summary Get supported blockchains. Currently only TON is supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getBlockchains(options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getBlockchains(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given decentralized exchange for the given blockchain
     * @param {string} blockchain 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDex(blockchain: string, name: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDex(blockchain, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of supported decentralized exchanges supported by the service in the given blockchain
     * @param {string} [blockchain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getDexes(blockchain?: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getDexes(blockchain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given liquidity pool for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getPool(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getPool(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given token for the given blockchain
     * @param {string} blockchain 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getToken(blockchain: string, address: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getToken(blockchain, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of tokens supported by the service
     * @param {boolean} [listed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokens(listed?: boolean, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokens(listed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the given token by its symbol for the given blockchain
     * @param {string} blockchain 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityApi
     */
    public getTokensBySymbol(blockchain: string, symbol: string, options?: RawAxiosRequestConfig) {
        return EntityApiFp(this.configuration).getTokensBySymbol(blockchain, symbol, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnershipApi - axios parameter creator
 * @export
 */
export const PartnershipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
         * @param {string} address 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionRecords: async (address: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getRawTransactionRecords', 'address', address)
            const localVarPath = `/v1/partnership/{address}/transactions`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnershipApi - functional programming interface
 * @export
 */
export const PartnershipApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnershipApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
         * @param {string} address 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawTransactionRecords(address: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiRawTransactionRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawTransactionRecords(address, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnershipApi.getRawTransactionRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnershipApi - factory interface
 * @export
 */
export const PartnershipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnershipApiFp(configuration)
    return {
        /**
         * 
         * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
         * @param {string} address 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawTransactionRecords(address: string, page?: number, options?: any): AxiosPromise<Array<ApiRawTransactionRecord>> {
            return localVarFp.getRawTransactionRecords(address, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnershipApi - object-oriented interface
 * @export
 * @class PartnershipApi
 * @extends {BaseAPI}
 */
export class PartnershipApi extends BaseAPI {
    /**
     * 
     * @summary Get raw transaction records with specified partner\'s referral address. Requires associated x-api-key.
     * @param {string} address 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnershipApi
     */
    public getRawTransactionRecords(address: string, page?: number, options?: RawAxiosRequestConfig) {
        return PartnershipApiFp(this.configuration).getRawTransactionRecords(address, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountSettings', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getAccountSettings', 'xVerify', xVerify)
            const localVarPath = `/v1/profile/{address}/settings`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTransactions: async (address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getHistoricalTransactions', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getHistoricalTransactions', 'xVerify', xVerify)
            const localVarPath = `/v1/profile/{address}/transactions`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (token2 !== undefined) {
                localVarQueryParameter['token2'] = token2;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettings: async (address: string, xVerify: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateAccountSettings', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('updateAccountSettings', 'xVerify', xVerify)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateAccountSettings', 'requestBody', requestBody)
            const localVarPath = `/v1/profile/{address}/settings`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProof: async (address: string, apiProofValidationRequest: ApiProofValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('validateProof', 'address', address)
            // verify required parameter 'apiProofValidationRequest' is not null or undefined
            assertParamExists('validateProof', 'apiProofValidationRequest', apiProofValidationRequest)
            const localVarPath = `/v1/profile/{address}/proof`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiProofValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountSettings(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountSettings(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiHistoricalTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalTransactions(address, xVerify, token, token2, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getHistoricalTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountSettings(address, xVerify, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.updateAccountSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateProof(address, apiProofValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.validateProof']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Get account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountSettings(address: string, xVerify: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getAccountSettings(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get historical account transactions on swap.coffee
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {string} [token] If set, only transactions related to this token will be returned
         * @param {string} [token2] If set, only transactions related to this token pair will be returned
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: any): AxiosPromise<Array<ApiHistoricalTransaction>> {
            return localVarFp.getHistoricalTransactions(address, xVerify, token, token2, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account settings
         * @param {string} address 
         * @param {string} xVerify 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<void> {
            return localVarFp.updateAccountSettings(address, xVerify, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate TON proof for given account address
         * @param {string} address 
         * @param {ApiProofValidationRequest} apiProofValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.validateProof(address, apiProofValidationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @summary Get account settings
     * @param {string} address 
     * @param {string} xVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getAccountSettings(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getAccountSettings(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get historical account transactions on swap.coffee
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {string} [token] If set, only transactions related to this token will be returned
     * @param {string} [token2] If set, only transactions related to this token pair will be returned
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getHistoricalTransactions(address: string, xVerify: string, token?: string, token2?: string, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getHistoricalTransactions(address, xVerify, token, token2, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account settings
     * @param {string} address 
     * @param {string} xVerify 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateAccountSettings(address: string, xVerify: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).updateAccountSettings(address, xVerify, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate TON proof for given account address
     * @param {string} address 
     * @param {ApiProofValidationRequest} apiProofValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public validateProof(address: string, apiProofValidationRequest: ApiProofValidationRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).validateProof(address, apiProofValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralApi - axios parameter creator
 * @export
 */
export const ReferralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindReferral: async (address: string, referral: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('bindReferral', 'address', address)
            // verify required parameter 'referral' is not null or undefined
            assertParamExists('bindReferral', 'referral', referral)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('bindReferral', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (referral !== undefined) {
                localVarQueryParameter['referral'] = referral;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralInfo: async (address: string, xVerify: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReferralInfo', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getReferralInfo', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralList: async (address: string, xVerify: string, size?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getReferralList', 'address', address)
            // verify required parameter 'xVerify' is not null or undefined
            assertParamExists('getReferralList', 'xVerify', xVerify)
            const localVarPath = `/v1/referral/{address}/list`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xVerify != null) {
                localVarHeaderParameter['x-verify'] = String(xVerify);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindReferral: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('unbindReferral', 'address', address)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update referral\'s info. For internal usage only.
         * @param {string} address 
         * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral: async (address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('updateReferral', 'address', address)
            // verify required parameter 'apiReferralAccountInfoUpdate' is not null or undefined
            assertParamExists('updateReferral', 'apiReferralAccountInfoUpdate', apiReferralAccountInfoUpdate)
            const localVarPath = `/v1/referral/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiReferralAccountInfoUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralApi - functional programming interface
 * @export
 */
export const ReferralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindReferral(address: string, referral: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindReferral(address, referral, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.bindReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferralInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiReferralAccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferralInfo(address, xVerify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.getReferralInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferralList(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiReferralInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferralList(address, xVerify, size, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.getReferralList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindReferral(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindReferral(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.unbindReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update referral\'s info. For internal usage only.
         * @param {string} address 
         * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReferral(address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReferral(address, apiReferralAccountInfoUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.updateReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralApi - factory interface
 * @export
 */
export const ReferralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralApiFp(configuration)
    return {
        /**
         * 
         * @summary Bind new referral
         * @param {string} address 
         * @param {string} referral 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindReferral(address: string, referral: string, xVerify: string, options?: any): AxiosPromise<void> {
            return localVarFp.bindReferral(address, referral, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s referral info
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralInfo(address: string, xVerify: string, options?: any): AxiosPromise<ApiReferralAccountInfo> {
            return localVarFp.getReferralInfo(address, xVerify, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s list of referrals
         * @param {string} address 
         * @param {string} xVerify TON proof for the given address
         * @param {number} [size] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferralList(address: string, xVerify: string, size?: number, page?: number, options?: any): AxiosPromise<Array<ApiReferralInfo>> {
            return localVarFp.getReferralList(address, xVerify, size, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unbind existing referral. For internal usage only.
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindReferral(address: string, options?: any): AxiosPromise<void> {
            return localVarFp.unbindReferral(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update referral\'s info. For internal usage only.
         * @param {string} address 
         * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral(address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updateReferral(address, apiReferralAccountInfoUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralApi - object-oriented interface
 * @export
 * @class ReferralApi
 * @extends {BaseAPI}
 */
export class ReferralApi extends BaseAPI {
    /**
     * 
     * @summary Bind new referral
     * @param {string} address 
     * @param {string} referral 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public bindReferral(address: string, referral: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).bindReferral(address, referral, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s referral info
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public getReferralInfo(address: string, xVerify: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).getReferralInfo(address, xVerify, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s list of referrals
     * @param {string} address 
     * @param {string} xVerify TON proof for the given address
     * @param {number} [size] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public getReferralList(address: string, xVerify: string, size?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).getReferralList(address, xVerify, size, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unbind existing referral. For internal usage only.
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public unbindReferral(address: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).unbindReferral(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update referral\'s info. For internal usage only.
     * @param {string} address 
     * @param {ApiReferralAccountInfoUpdate} apiReferralAccountInfoUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralApi
     */
    public updateReferral(address: string, apiReferralAccountInfoUpdate: ApiReferralAccountInfoUpdate, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).updateReferral(address, apiReferralAccountInfoUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoutingApi - axios parameter creator
 * @export
 */
export const RoutingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute: async (apiRouteRequest: ApiRouteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiRouteRequest' is not null or undefined
            assertParamExists('buildRoute', 'apiRouteRequest', apiRouteRequest)
            const localVarPath = `/v1/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRouteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonStakeTransaction: async (apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTonStakingTransactionRequest' is not null or undefined
            assertParamExists('buildTonStakeTransaction', 'apiTonStakingTransactionRequest', apiTonStakingTransactionRequest)
            const localVarPath = `/v2/stake/ton/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTonStakingTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonUnstakeTransaction: async (apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTonStakingTransactionRequest' is not null or undefined
            assertParamExists('buildTonUnstakeTransaction', 'apiTonStakingTransactionRequest', apiTonStakingTransactionRequest)
            const localVarPath = `/v2/unstake/ton/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTonStakingTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2: async (apiTransactionsRequest: ApiTransactionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiTransactionsRequest' is not null or undefined
            assertParamExists('buildTransactionsV2', 'apiTransactionsRequest', apiTransactionsRequest)
            const localVarPath = `/v2/route/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsResult: async (queryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryId' is not null or undefined
            assertParamExists('getTransactionsResult', 'queryId', queryId)
            const localVarPath = `/v1/route/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (queryId !== undefined) {
                localVarQueryParameter['query_id'] = queryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutingApi - functional programming interface
 * @export
 */
export const RoutingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoutingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiRoute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildRoute(apiRouteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTonStakeTransaction(apiTonStakingTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTonStakeTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionBoc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTonUnstakeTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildTransactionsV2(apiTransactionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.buildTransactionsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTransactionResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsResult(queryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoutingApi.getTransactionsResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoutingApi - factory interface
 * @export
 */
export const RoutingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutingApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the best route for the given trade pair
         * @param {ApiRouteRequest} apiRouteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildRoute(apiRouteRequest: ApiRouteRequest, options?: any): AxiosPromise<ApiRoute> {
            return localVarFp.buildRoute(apiRouteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: any): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.buildTonStakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
         * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: any): AxiosPromise<ApiTransactionBoc> {
            return localVarFp.buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
         * @param {ApiTransactionsRequest} apiTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: any): AxiosPromise<ApiTransactionsResponse> {
            return localVarFp.buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get route transactions execution result
         * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsResult(queryId: number, options?: any): AxiosPromise<Array<ApiTransactionResult>> {
            return localVarFp.getTransactionsResult(queryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutingApi - object-oriented interface
 * @export
 * @class RoutingApi
 * @extends {BaseAPI}
 */
export class RoutingApi extends BaseAPI {
    /**
     * 
     * @summary Returns the best route for the given trade pair
     * @param {ApiRouteRequest} apiRouteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildRoute(apiRouteRequest: ApiRouteRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildRoute(apiRouteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns pre-built transaction for the given stake request. It is assumed that transaction will be signed and sent by the sender via wallet
     * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTonStakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTonStakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns pre-built transaction for the given unstake request. It is assumed that transaction will be signed and sent by the sender via wallet
     * @param {ApiTonStakingTransactionRequest} apiTonStakingTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTonUnstakeTransaction(apiTonStakingTransactionRequest: ApiTonStakingTransactionRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTonUnstakeTransaction(apiTonStakingTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns pre-built transactions for the given route. It is assumed that transactions will be signed and sent by the sender via wallet
     * @param {ApiTransactionsRequest} apiTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public buildTransactionsV2(apiTransactionsRequest: ApiTransactionsRequest, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).buildTransactionsV2(apiTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get route transactions execution result
     * @param {number} queryId Actually it\&#39;s route_id, but saved old naming for back-compatibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutingApi
     */
    public getTransactionsResult(queryId: number, options?: RawAxiosRequestConfig) {
        return RoutingApiFp(this.configuration).getTransactionsResult(queryId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TonApi - axios parameter creator
 * @export
 */
export const TonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletBalance', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/balance`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getWalletVersion', 'address', address)
            const localVarPath = `/v1/ton/wallet/{address}/version`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TonApi - functional programming interface
 * @export
 */
export const TonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletBalance(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletVersion(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWalletVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletVersion(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TonApi.getWalletVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TonApi - factory interface
 * @export
 */
export const TonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TonApiFp(configuration)
    return {
        /**
         * 
         * @summary Get wallet balance in nanotons (1e-9 TON)
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance(address: string, options?: any): AxiosPromise<string> {
            return localVarFp.getWalletBalance(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns wallet version and revision
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletVersion(address: string, options?: any): AxiosPromise<GetWalletVersion200Response> {
            return localVarFp.getWalletVersion(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TonApi - object-oriented interface
 * @export
 * @class TonApi
 * @extends {BaseAPI}
 */
export class TonApi extends BaseAPI {
    /**
     * 
     * @summary Get wallet balance in nanotons (1e-9 TON)
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletBalance(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletBalance(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns wallet version and revision
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TonApi
     */
    public getWalletVersion(address: string, options?: RawAxiosRequestConfig) {
        return TonApiFp(this.configuration).getWalletVersion(address, options).then((request) => request(this.axios, this.basePath));
    }
}



